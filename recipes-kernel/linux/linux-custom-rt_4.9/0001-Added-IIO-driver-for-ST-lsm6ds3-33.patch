From 5f553f6d34b33aa7afc8e6c5d95e505cf27177f8 Mon Sep 17 00:00:00 2001
From: Thomas Federspiel <thomas@federspiel.se>
Date: Sat, 12 Jan 2019 16:17:17 +0100
Subject: [PATCH] Added IIO driver for ST lsm6ds3/33

---
 drivers/iio/imu/Kconfig                            |    2 +
 drivers/iio/imu/Makefile                           |    2 +
 drivers/iio/imu/st_lsm6ds3/Kconfig                 |   94 +
 drivers/iio/imu/st_lsm6ds3/Makefile                |   12 +
 drivers/iio/imu/st_lsm6ds3/st_lsm6ds3.h            |  372 +++
 drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_buffer.c     |  662 ++++
 drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_core.c       | 3171 ++++++++++++++++++++
 drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_i2c.c        |  180 ++
 drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_i2c_master.c | 1781 +++++++++++
 drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_spi.c        |  201 ++
 drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_trigger.c    |  206 ++
 11 files changed, 6683 insertions(+)
 create mode 100755 drivers/iio/imu/st_lsm6ds3/Kconfig
 create mode 100755 drivers/iio/imu/st_lsm6ds3/Makefile
 create mode 100755 drivers/iio/imu/st_lsm6ds3/st_lsm6ds3.h
 create mode 100755 drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_buffer.c
 create mode 100755 drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_core.c
 create mode 100755 drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_i2c.c
 create mode 100755 drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_i2c_master.c
 create mode 100755 drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_spi.c
 create mode 100755 drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_trigger.c

diff --git a/drivers/iio/imu/Kconfig b/drivers/iio/imu/Kconfig
index 1f1ad41..cebc768 100644
--- a/drivers/iio/imu/Kconfig
+++ b/drivers/iio/imu/Kconfig
@@ -39,6 +39,7 @@ config KMX61
 	  be called kmx61.
 
 source "drivers/iio/imu/inv_mpu6050/Kconfig"
+source "drivers/iio/imu/st_lsm6ds3/Kconfig"
 
 endmenu
 
@@ -53,3 +54,4 @@ config IIO_ADIS_LIB_BUFFER
 	help
 	  A set of buffer helper functions for the Analog Devices ADIS* device
 	  family.
+
diff --git a/drivers/iio/imu/Makefile b/drivers/iio/imu/Makefile
index c71bcd3..4182211 100644
--- a/drivers/iio/imu/Makefile
+++ b/drivers/iio/imu/Makefile
@@ -17,3 +17,5 @@ obj-y += bmi160/
 obj-y += inv_mpu6050/
 
 obj-$(CONFIG_KMX61) += kmx61.o
+
+obj-y += st_lsm6ds3/
diff --git a/drivers/iio/imu/st_lsm6ds3/Kconfig b/drivers/iio/imu/st_lsm6ds3/Kconfig
new file mode 100755
index 0000000..d821f0f
--- /dev/null
+++ b/drivers/iio/imu/st_lsm6ds3/Kconfig
@@ -0,0 +1,94 @@
+#
+# st-lsm6ds3 drivers for STMicroelectronics combo sensor
+#
+
+menuconfig ST_LSM6DS3_IIO
+	tristate "STMicroelectronics LSM6DS3/LSM6DS33 sensor"
+	depends on (I2C || SPI) && SYSFS
+	select IIO_BUFFER
+	select IIO_TRIGGERED_BUFFER
+	select ST_LSM6DS3_I2C_IIO if (I2C)
+	select ST_LSM6DS3_SPI_IIO if (SPI)
+	help
+	  This driver supports LSM6DS3 and LSM6DS33 sensors.
+	  It is a gyroscope/accelerometer combo device.
+	  This driver can be built as a module. The module will be called
+	  st-lsm6ds3.
+
+if ST_LSM6DS3_IIO
+
+config ST_LSM6DS3_I2C_IIO
+	tristate
+	depends on ST_LSM6DS3_IIO
+	depends on I2C
+
+config ST_LSM6DS3_SPI_IIO
+	tristate
+	depends on ST_LSM6DS3_IIO
+	depends on SPI
+
+config ST_LSM6DS3_IIO_LIMIT_FIFO
+	int "Limit fifo read lenght (#n byte)"
+	depends on ST_LSM6DS3_IIO
+	range 0 8192
+	default 0
+	help
+	  Limit atomic fifo read to #n byte. In some platform i2c/spi read
+	  can be limited by software or hardware.
+	  
+	  Set 0 to disable the limit.
+
+config ST_LSM6DS3_STEP_COUNTER_ON_DURING_SUSPEND
+	bool "Keep Step counter on during suspend"
+	depends on ST_LSM6DS3_IIO
+	default n
+	help
+	  During suspend step counter is kept on if enabled. Only interrupt
+	  is disabled.
+
+menuconfig ST_LSM6DS3_IIO_MASTER_SUPPORT
+	bool "I2C master controller"
+	depends on I2C && ST_LSM6DS3_IIO
+	default n
+	help
+	  Added support for I2C master controller. Supported sensors up
+	  to 4.
+
+if ST_LSM6DS3_IIO_MASTER_SUPPORT
+
+config ST_LSM6DS3_ENABLE_INTERNAL_PULLUP
+	bool "Enabled internals pull-up resistors"
+	default y
+
+choice
+	prompt "External sensor 0"
+	default ST_LSM6DS3_IIO_EXT0_LIS3MDL
+	help
+	  Choose the external sensor 0 connected to LSM6DS3.
+
+config ST_LSM6DS3_IIO_EXT0_LIS3MDL
+	bool "LIS3MDL"
+config ST_LSM6DS3_IIO_EXT0_AKM09911
+	bool "AKM09911"
+config ST_LSM6DS3_IIO_EXT0_AKM09912
+	bool "AKM09912"
+config ST_LSM6DS3_IIO_EXT0_AKM09916
+	bool "AKM09916"
+config ST_LSM6DS3_IIO_EXT0_LPS22HB
+	bool "LPS22HB"
+config ST_LSM6DS3_IIO_EXT0_LIS2MDL
+	bool "LIS2MDL"
+endchoice
+
+endif
+
+config ST_LSM6DS3_XL_DATA_INJECTION
+	bool "Enable XL data injection support"
+	depends on ST_LSM6DS3_IIO
+	default n
+	help
+	  This option enables the accelerometer data injection
+	  support. The device functions may so use an injected
+	  pattern instead of taking the real sensor data.
+
+endif #ST_LSM6DS3_IIO
diff --git a/drivers/iio/imu/st_lsm6ds3/Makefile b/drivers/iio/imu/st_lsm6ds3/Makefile
new file mode 100755
index 0000000..d8b6dec
--- /dev/null
+++ b/drivers/iio/imu/st_lsm6ds3/Makefile
@@ -0,0 +1,12 @@
+#
+# Makefile for STMicroelectronics LSM6DS3 sensor.
+#
+
+obj-$(CONFIG_ST_LSM6DS3_IIO) += st_lsm6ds3.o
+st_lsm6ds3-objs := st_lsm6ds3_core.o
+obj-$(CONFIG_ST_LSM6DS3_I2C_IIO) += st_lsm6ds3_i2c.o
+obj-$(CONFIG_ST_LSM6DS3_SPI_IIO) += st_lsm6ds3_spi.o
+
+st_lsm6ds3-$(CONFIG_IIO_BUFFER) += st_lsm6ds3_buffer.o
+st_lsm6ds3-$(CONFIG_IIO_TRIGGER) += st_lsm6ds3_trigger.o
+st_lsm6ds3-$(CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT) += st_lsm6ds3_i2c_master.o
diff --git a/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3.h b/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3.h
new file mode 100755
index 0000000..929c1ca
--- /dev/null
+++ b/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3.h
@@ -0,0 +1,372 @@
+/*
+ * STMicroelectronics lsm6ds3 driver
+ *
+ * Copyright 2014-2016 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef ST_LSM6DS3_H
+#define ST_LSM6DS3_H
+
+#include <linux/types.h>
+#include <linux/iio/trigger.h>
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+#include <linux/i2c.h>
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+
+#define LSM6DS3_DEV_NAME			"lsm6ds3"
+#define LSM6DS33_DEV_NAME			"lsm6ds33"
+
+enum st_mask_id {
+	ST_MASK_ID_ACCEL = 0,
+	ST_MASK_ID_GYRO,
+	ST_MASK_ID_SIGN_MOTION,
+	ST_MASK_ID_STEP_COUNTER,
+	ST_MASK_ID_STEP_DETECTOR,
+	ST_MASK_ID_TILT,
+	ST_MASK_ID_EXT0,
+	ST_MASK_ID_HW_PEDOMETER,
+	ST_MASK_ID_SENSOR_HUB,
+	ST_MASK_ID_DIGITAL_FUNC,
+	ST_MASK_ID_SENSOR_HUB_ASYNC_OP,
+};
+
+#define ST_INDIO_DEV_NUM			6
+
+#define ST_LSM6DS3_TX_MAX_LENGTH		12
+#define ST_LSM6DS3_RX_MAX_LENGTH		8193
+
+#define ST_LSM6DS3_BYTE_FOR_CHANNEL		2
+#define ST_LSM6DS3_FIFO_ELEMENT_LEN_BYTE	6
+
+#define ST_LSM6DS3_MAX_FIFO_SIZE		8192
+#define ST_LSM6DS3_MAX_FIFO_THRESHOLD		1092
+#define ST_LSM6DS3_MAX_FIFO_LENGHT		(ST_LSM6DS3_MAX_FIFO_SIZE / \
+					ST_LSM6DS3_FIFO_ELEMENT_LEN_BYTE)
+
+#define ST_LSM6DS3_SELFTEST_NA_MS		"na"
+#define ST_LSM6DS3_SELFTEST_FAIL_MS		"fail"
+#define ST_LSM6DS3_SELFTEST_PASS_MS		"pass"
+
+#define ST_LSM6DS3_WAKE_UP_SENSORS	(BIT(ST_MASK_ID_SIGN_MOTION) | \
+					BIT(ST_MASK_ID_TILT))
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+#define ST_LSM6DS3_NUM_CLIENTS			1
+#else /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+#define ST_LSM6DS3_NUM_CLIENTS			0
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+
+#define ST_LSM6DS3_LSM_CHANNELS(device_type, modif, index, mod, \
+						endian, sbits, rbits, addr, s) \
+{ \
+	.type = device_type, \
+	.modified = modif, \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
+			BIT(IIO_CHAN_INFO_SCALE), \
+	.scan_index = index, \
+	.channel2 = mod, \
+	.address = addr, \
+	.scan_type = { \
+		.sign = s, \
+		.realbits = rbits, \
+		.shift = sbits - rbits, \
+		.storagebits = sbits, \
+		.endianness = endian, \
+	}, \
+}
+
+extern const struct iio_event_spec lsm6ds3_fifo_flush_event;
+
+#define ST_LSM6DS3_FLUSH_CHANNEL(device_type) \
+{ \
+	.type = device_type, \
+	.modified = 0, \
+	.scan_index = -1, \
+	.indexed = -1, \
+	.event_spec = &lsm6ds3_fifo_flush_event,\
+	.num_event_specs = 1, \
+}
+
+#define ST_LSM6DS3_HWFIFO_ENABLED() \
+	IIO_DEVICE_ATTR(hwfifo_enabled, S_IWUSR | S_IRUGO, \
+			st_lsm6ds3_sysfs_get_hwfifo_enabled,\
+			st_lsm6ds3_sysfs_set_hwfifo_enabled, 0);
+
+#define ST_LSM6DS3_HWFIFO_WATERMARK() \
+	IIO_DEVICE_ATTR(hwfifo_watermark, S_IWUSR | S_IRUGO, \
+			st_lsm6ds3_sysfs_get_hwfifo_watermark,\
+			st_lsm6ds3_sysfs_set_hwfifo_watermark, 0);
+
+#define ST_LSM6DS3_HWFIFO_WATERMARK_MIN() \
+	IIO_DEVICE_ATTR(hwfifo_watermark_min, S_IRUGO, \
+			st_lsm6ds3_sysfs_get_hwfifo_watermark_min, NULL, 0);
+
+#define ST_LSM6DS3_HWFIFO_WATERMARK_MAX() \
+	IIO_DEVICE_ATTR(hwfifo_watermark_max, S_IRUGO, \
+			st_lsm6ds3_sysfs_get_hwfifo_watermark_max, NULL, 0);
+
+#define ST_LSM6DS3_HWFIFO_FLUSH() \
+	IIO_DEVICE_ATTR(hwfifo_flush, S_IWUSR, NULL, \
+			st_lsm6ds3_sysfs_flush_fifo, 0);
+
+enum fifo_mode {
+	BYPASS = 0,
+	CONTINUOS,
+};
+
+struct st_lsm6ds3_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[ST_LSM6DS3_RX_MAX_LENGTH];
+	u8 tx_buf[ST_LSM6DS3_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+struct lsm6ds3_out_decimation {
+	short decimator;
+	short num_samples;
+};
+
+struct lsm6ds3_fifo_output {
+	u8 sip;
+	int64_t deltatime;
+	int64_t deltatime_default;
+	int64_t timestamp;
+	int64_t timestamp_p;
+	short decimator;
+	short num_samples;
+	bool initialized;
+};
+
+/* struct lsm6ds3_data - common data for i2c or spi driver instance
+ * @name: pointer to the device name (i2c name or spi modalias).
+ * @spi_connection: set if driver probed by i2c or spi.
+ * @enable_digfunc_mask: mask used to enable/disable hw digital functions.
+ * @enable_pedometer_mask: mask used to enable/disable hw pedometer function.
+ * @enable_sensorhub_mask: mask used to enable/disable sensor-hub feature.
+ * @irq_enable_fifo_mask: mask used to enable/disable fifo irq.
+ * @irq_enable_accel_ext_mask: mask used to enable/disable accel irq.
+ * @hw_odr: physical sensor odr expressed in Hz.
+ * @v_odr: requested sensor odr by userspace expressed in Hz.
+ * @hwfifo_enabled: is hwfifo enabled?
+ * @hwfifo_decimator: hwfifo decimator factor.
+ * @hwfifo_watermark: hwfifo watermark value.
+ * @samples_to_discard: samples to discard due to ODR switch.
+ * @nofifo_decimation: output status when fifo is disabled.
+ * @fifo_output: output status when fifo is enabled.
+ * @sensors_enabled: sensors enabled mask.
+ * @sensors_use_fifo: sensors use fifo mask.
+ * @accel_odr_dependency: odr dependency: accel, sensor-hub, dig-func.
+ * @accel_on: accel is going to be enabled during fifo odr switch?
+ * @magn_on: magn is going to be enabled during fifo odr switch?
+ * @odr_lock: mutex to avoid race condition during odr switch.
+ * @reset_steps: do I need to reset number of steps?
+ * @sign_motion_event_ready: significan motion event is ready to be pushed.
+ * @fifo_data: fifo data.
+ * @gyro_selftest_status: gyroscope selftest result.
+ * @accel_selftest_status: accelerometer selftest result.
+ * @irq: irq number.
+ * @timestamp: timestamp value from boot process.
+ */
+struct lsm6ds3_data {
+	const char *name;
+
+	bool spi_connection;
+
+	u16 enable_digfunc_mask;
+	u16 enable_pedometer_mask;
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+	u16 enable_sensorhub_mask;
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+
+	u16 irq_enable_fifo_mask;
+	u16 irq_enable_accel_ext_mask;
+
+	unsigned int hw_odr[ST_INDIO_DEV_NUM + 1];
+	unsigned int v_odr[ST_INDIO_DEV_NUM + 1];
+	unsigned int trigger_odr;
+
+	bool hwfifo_enabled[ST_INDIO_DEV_NUM + 1];
+	u8 hwfifo_decimator[ST_INDIO_DEV_NUM + 1];
+	u16 hwfifo_watermark[ST_INDIO_DEV_NUM + 1];
+	u16 fifo_watermark;
+
+	u8 samples_to_discard[ST_INDIO_DEV_NUM + 1];
+	u8 samples_to_discard_2[ST_INDIO_DEV_NUM + 1];
+	struct lsm6ds3_out_decimation nofifo_decimation[ST_INDIO_DEV_NUM + 1];
+	struct lsm6ds3_fifo_output fifo_output[ST_INDIO_DEV_NUM + 1];
+
+	u16 sensors_enabled;
+	u16 sensors_use_fifo;
+	u64 num_steps;
+
+	int accel_odr_dependency[3];
+
+	bool accel_on;
+	bool magn_on;
+	enum fifo_mode fifo_status;
+
+	struct mutex odr_lock;
+
+	bool reset_steps;
+	bool sign_motion_event_ready;
+
+	u8 *fifo_data;
+	u8 accel_last_push[6];
+	u8 gyro_last_push[6];
+	u8 ext0_last_push[6];
+	int8_t gyro_selftest_status;
+	int8_t accel_selftest_status;
+
+	int irq;
+
+	s64 timestamp;
+	int64_t fifo_enable_timestamp;
+	int64_t slower_counter;
+	uint8_t slower_id;
+
+#ifdef CONFIG_ST_LSM6DS3_XL_DATA_INJECTION
+	bool injection_mode;
+	s64 last_injection_timestamp;
+	struct hrtimer injection_timer;
+	struct work_struct injection_work;
+	spinlock_t injection_spinlock;
+	u8 injection_data[30];
+	u8 injection_samples;
+#endif /* CONFIG_ST_LSM6DS3_XL_DATA_INJECTION */
+
+	struct work_struct data_work;
+
+	struct device *dev;
+	struct iio_dev *indio_dev[ST_INDIO_DEV_NUM + 1];
+	struct iio_trigger *trig[ST_INDIO_DEV_NUM + 1];
+	struct mutex bank_registers_lock;
+	struct mutex fifo_lock;
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+	bool ext0_available;
+	int8_t ext0_selftest_status;
+	struct mutex i2c_transfer_lock;
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+
+	const struct st_lsm6ds3_transfer_function *tf;
+	struct st_lsm6ds3_transfer_buffer tb;
+};
+
+struct st_lsm6ds3_transfer_function {
+	int (*write)(struct lsm6ds3_data *cdata,
+				u8 reg_addr, int len, u8 *data, bool b_lock);
+	int (*read)(struct lsm6ds3_data *cdata,
+				u8 reg_addr, int len, u8 *data, bool b_lock);
+};
+
+struct lsm6ds3_sensor_data {
+	struct lsm6ds3_data *cdata;
+
+	unsigned int c_gain[3];
+
+	u8 num_data_channels;
+	u8 sindex;
+	u8 data_out_reg;
+	u8 *buffer_data;
+};
+
+int st_lsm6ds3_write_data_with_mask(struct lsm6ds3_data *cdata,
+			u8 reg_addr, u8 mask, u8 data, bool b_lock);
+
+int st_lsm6ds3_push_data_with_timestamp(struct lsm6ds3_data *cdata,
+					u8 index, u8 *data, int64_t timestamp);
+
+int st_lsm6ds3_common_probe(struct lsm6ds3_data *cdata, int irq);
+void st_lsm6ds3_common_remove(struct lsm6ds3_data *cdata, int irq);
+
+int st_lsm6ds3_set_enable(struct lsm6ds3_sensor_data *sdata, bool enable, bool buffer);
+int st_lsm6ds3_set_fifo_mode(struct lsm6ds3_data *cdata, enum fifo_mode fm);
+int st_lsm6ds3_enable_sensor_hub(struct lsm6ds3_data *cdata, bool enable,
+							enum st_mask_id id);
+int lsm6ds3_read_output_data(struct lsm6ds3_data *cdata, int sindex, bool push);
+int st_lsm6ds3_set_drdy_irq(struct lsm6ds3_sensor_data *sdata, bool state);
+
+ssize_t st_lsm6ds3_sysfs_get_hwfifo_enabled(struct device *dev,
+				struct device_attribute *attr, char *buf);
+ssize_t st_lsm6ds3_sysfs_set_hwfifo_enabled(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size);
+ssize_t st_lsm6ds3_sysfs_get_hwfifo_watermark(struct device *dev,
+				struct device_attribute *attr, char *buf);
+ssize_t st_lsm6ds3_sysfs_set_hwfifo_watermark(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size);
+ssize_t st_lsm6ds3_sysfs_get_hwfifo_watermark_max(struct device *dev,
+				struct device_attribute *attr, char *buf);
+ssize_t st_lsm6ds3_sysfs_get_hwfifo_watermark_min(struct device *dev,
+				struct device_attribute *attr, char *buf);
+ssize_t st_lsm6ds3_sysfs_flush_fifo(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size);
+
+#ifdef CONFIG_IIO_BUFFER
+int st_lsm6ds3_allocate_rings(struct lsm6ds3_data *cdata);
+void st_lsm6ds3_deallocate_rings(struct lsm6ds3_data *cdata);
+int st_lsm6ds3_trig_set_state(struct iio_trigger *trig, bool state);
+int st_lsm6ds3_read_fifo(struct lsm6ds3_data *cdata, bool async);
+#define ST_LSM6DS3_TRIGGER_SET_STATE (&st_lsm6ds3_trig_set_state)
+#else /* CONFIG_IIO_BUFFER */
+static inline int st_lsm6ds3_allocate_rings(struct lsm6ds3_data *cdata)
+{
+	return 0;
+}
+static inline void st_lsm6ds3_deallocate_rings(struct lsm6ds3_data *cdata)
+{
+}
+static inline int st_lsm6ds3_read_fifo(struct lsm6ds3_data *cdata, bool async)
+{
+	return 0;
+}
+#define ST_LSM6DS3_TRIGGER_SET_STATE NULL
+#endif /* CONFIG_IIO_BUFFER */
+
+#ifdef CONFIG_IIO_TRIGGER
+int st_lsm6ds3_allocate_triggers(struct lsm6ds3_data *cdata,
+				const struct iio_trigger_ops *trigger_ops);
+void st_lsm6ds3_deallocate_triggers(struct lsm6ds3_data *cdata);
+void st_lsm6ds3_flush_works(void);
+#else /* CONFIG_IIO_TRIGGER */
+static inline int st_lsm6ds3_allocate_triggers(struct lsm6ds3_data *cdata,
+			const struct iio_trigger_ops *trigger_ops, int irq)
+{
+	return 0;
+}
+static inline void st_lsm6ds3_deallocate_triggers(struct lsm6ds3_data *cdata,
+								int irq)
+{
+	return;
+}
+static inline void st_lsm6ds3_flush_works(void)
+{
+	return;
+}
+#endif /* CONFIG_IIO_TRIGGER */
+
+#ifdef CONFIG_PM
+int st_lsm6ds3_common_suspend(struct lsm6ds3_data *cdata);
+int st_lsm6ds3_common_resume(struct lsm6ds3_data *cdata);
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+int st_lsm6ds3_write_embedded_registers(struct lsm6ds3_data *cdata,
+						u8 reg_addr, u8 *data, int len);
+int st_lsm6ds3_i2c_master_probe(struct lsm6ds3_data *cdata);
+int st_lsm6ds3_i2c_master_exit(struct lsm6ds3_data *cdata);
+#else /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+static inline int st_lsm6ds3_i2c_master_probe(struct lsm6ds3_data *cdata)
+{
+	return 0;
+}
+static inline int st_lsm6ds3_i2c_master_exit(struct lsm6ds3_data *cdata)
+{
+	return 0;
+}
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+
+#endif /* ST_LSM6DS3_H */
diff --git a/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_buffer.c b/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_buffer.c
new file mode 100755
index 0000000..b6d71f7
--- /dev/null
+++ b/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_buffer.c
@@ -0,0 +1,662 @@
+/*
+ * STMicroelectronics lsm6ds3 buffer driver
+ *
+ * Copyright 2014-2016 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/stat.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/iio/triggered_buffer.h>
+
+#include "st_lsm6ds3.h"
+
+#define ST_LSM6DS3_ENABLE_AXIS			0x07
+#define ST_LSM6DS3_FIFO_DIFF_L			0x3a
+#define ST_LSM6DS3_FIFO_DIFF_MASK		0x0f
+#define ST_LSM6DS3_FIFO_DATA_OUT_L		0x3e
+#define ST_LSM6DS3_FIFO_DATA_OVR		0x40
+#define ST_LSM6DS3_FIFO_DATA_EMPTY		0x10
+#define ST_LSM6DS3_STEP_MASK_64BIT		(0xFFFFFFFFFFFF0000)
+
+#define MIN_ID(a, b, c, d)			(((a) < (b)) ? ((a == 0) ? \
+						(d) : (c)) : ((b == 0) ? \
+						(c) : (d)))
+
+int st_lsm6ds3_push_data_with_timestamp(struct lsm6ds3_data *cdata,
+					u8 index, u8 *data, int64_t timestamp)
+{
+	size_t offset;
+	int i, n = 0;
+	struct iio_chan_spec const *chs = cdata->indio_dev[index]->channels;
+	uint16_t bfch, bfchs_out = 0, bfchs_in = 0;
+	struct lsm6ds3_sensor_data *sdata = iio_priv(cdata->indio_dev[index]);
+
+	if (timestamp <= cdata->fifo_output[index].timestamp_p)
+		return -EINVAL;
+
+	for (i = 0; i < sdata->num_data_channels; i++) {
+		bfch = chs[i].scan_type.storagebits >> 3;
+
+		if (test_bit(i, cdata->indio_dev[index]->active_scan_mask)) {
+			memcpy(&sdata->buffer_data[bfchs_out],
+						&data[bfchs_in], bfch);
+			n++;
+			bfchs_out += bfch;
+		}
+
+		bfchs_in += bfch;
+	}
+
+	if (cdata->indio_dev[index]->scan_timestamp) {
+		offset = cdata->indio_dev[index]->scan_bytes / sizeof(s64) - 1;
+		((s64 *)sdata->buffer_data)[offset] = timestamp;
+	}
+
+	iio_push_to_buffers(cdata->indio_dev[index], sdata->buffer_data);
+
+	cdata->fifo_output[index].timestamp_p = timestamp;
+
+	return 0;
+}
+
+static void st_lsm6ds3_parse_fifo_data(struct lsm6ds3_data *cdata,
+			u16 read_len, int64_t time_top, u16 num_pattern)
+{
+	int err;
+	u16 fifo_offset = 0;
+	u8 gyro_sip, accel_sip;
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+	u8 ext0_sip;
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+
+	while (fifo_offset < read_len) {
+		gyro_sip = cdata->fifo_output[ST_MASK_ID_GYRO].sip;
+		accel_sip = cdata->fifo_output[ST_MASK_ID_ACCEL].sip;
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+		ext0_sip = cdata->fifo_output[ST_MASK_ID_EXT0].sip;
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+
+		do {
+			if (gyro_sip > 0) {
+				if (cdata->fifo_output[ST_MASK_ID_GYRO].timestamp == 0) {
+					if (cdata->slower_id == ST_MASK_ID_GYRO)
+						cdata->fifo_output[ST_MASK_ID_GYRO].timestamp = time_top -
+							(num_pattern * gyro_sip * cdata->fifo_output[ST_MASK_ID_GYRO].deltatime) - 300000;
+					else
+						cdata->fifo_output[ST_MASK_ID_GYRO].timestamp = time_top -
+							(num_pattern * gyro_sip * cdata->fifo_output[ST_MASK_ID_GYRO].deltatime) - 300000 -
+							(cdata->fifo_output[cdata->slower_id].deltatime - cdata->fifo_output[ST_MASK_ID_GYRO].deltatime);
+				} else
+					cdata->fifo_output[ST_MASK_ID_GYRO].timestamp += cdata->fifo_output[ST_MASK_ID_GYRO].deltatime;
+
+				if (cdata->fifo_output[ST_MASK_ID_GYRO].timestamp > time_top) {
+					cdata->fifo_output[ST_MASK_ID_GYRO].timestamp -= cdata->fifo_output[ST_MASK_ID_GYRO].deltatime;
+					cdata->samples_to_discard[ST_MASK_ID_GYRO] = 1;
+				}
+
+				if (cdata->samples_to_discard[ST_MASK_ID_GYRO] > 0)
+					cdata->samples_to_discard[ST_MASK_ID_GYRO]--;
+				else {
+					cdata->fifo_output[ST_MASK_ID_GYRO].num_samples++;
+
+					if (cdata->fifo_output[ST_MASK_ID_GYRO].num_samples >= cdata->fifo_output[ST_MASK_ID_GYRO].decimator) {
+						cdata->fifo_output[ST_MASK_ID_GYRO].num_samples = 0;
+
+						if (cdata->sensors_enabled & BIT(ST_MASK_ID_GYRO)) {
+							if (cdata->samples_to_discard_2[ST_MASK_ID_GYRO] == 0) {
+								err = st_lsm6ds3_push_data_with_timestamp(
+									cdata, ST_MASK_ID_GYRO,
+									&cdata->fifo_data[fifo_offset],
+									cdata->fifo_output[ST_MASK_ID_GYRO].timestamp);
+
+								if (err >= 0)
+									cdata->fifo_output[ST_MASK_ID_GYRO].initialized = true;
+
+								memcpy(cdata->gyro_last_push, &cdata->fifo_data[fifo_offset], 6);
+							} else {
+								cdata->samples_to_discard_2[ST_MASK_ID_GYRO]--;
+
+								if (cdata->fifo_output[ST_MASK_ID_GYRO].initialized) {
+									err = st_lsm6ds3_push_data_with_timestamp(
+										cdata, ST_MASK_ID_GYRO,
+										cdata->gyro_last_push,
+										cdata->fifo_output[ST_MASK_ID_GYRO].timestamp);
+								}
+							}
+						}
+					}
+				}
+
+				fifo_offset += ST_LSM6DS3_FIFO_ELEMENT_LEN_BYTE;
+				gyro_sip--;
+			}
+
+			if (accel_sip > 0) {
+				if (cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp == 0) {
+					if (cdata->slower_id == ST_MASK_ID_ACCEL)
+						cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp = time_top -
+							(num_pattern * accel_sip * cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime) - 300000;
+					else
+						cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp = time_top -
+							(num_pattern * accel_sip * cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime) - 300000 -
+							(cdata->fifo_output[cdata->slower_id].deltatime - cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime);
+				} else
+					cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp += cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime;
+
+				if (cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp > time_top) {
+					cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp -= cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime;
+					cdata->samples_to_discard[ST_MASK_ID_ACCEL] = 1;
+				}
+
+				if (cdata->samples_to_discard[ST_MASK_ID_ACCEL] > 0)
+					cdata->samples_to_discard[ST_MASK_ID_ACCEL]--;
+				else {
+					cdata->fifo_output[ST_MASK_ID_ACCEL].num_samples++;
+
+					if (cdata->fifo_output[ST_MASK_ID_ACCEL].num_samples >= cdata->fifo_output[ST_MASK_ID_ACCEL].decimator) {
+						cdata->fifo_output[ST_MASK_ID_ACCEL].num_samples = 0;
+
+						if (cdata->sensors_enabled & BIT(ST_MASK_ID_ACCEL)) {
+							if (cdata->samples_to_discard_2[ST_MASK_ID_ACCEL] == 0) {
+								err = st_lsm6ds3_push_data_with_timestamp(
+									cdata, ST_MASK_ID_ACCEL,
+									&cdata->fifo_data[fifo_offset],
+									cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp);
+
+								if (err >= 0)
+									cdata->fifo_output[ST_MASK_ID_ACCEL].initialized = true;
+
+								memcpy(cdata->accel_last_push, &cdata->fifo_data[fifo_offset], 6);
+							} else {
+								cdata->samples_to_discard_2[ST_MASK_ID_ACCEL]--;
+
+								if (cdata->fifo_output[ST_MASK_ID_ACCEL].initialized) {
+									err = st_lsm6ds3_push_data_with_timestamp(
+										cdata, ST_MASK_ID_ACCEL,
+										cdata->accel_last_push,
+										cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp);
+								}
+							}
+						}
+					}
+				}
+
+				fifo_offset += ST_LSM6DS3_FIFO_ELEMENT_LEN_BYTE;
+				accel_sip--;
+			}
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+			if (ext0_sip > 0) {
+				if (cdata->fifo_output[ST_MASK_ID_EXT0].timestamp == 0) {
+					if (cdata->slower_id == ST_MASK_ID_EXT0)
+						cdata->fifo_output[ST_MASK_ID_EXT0].timestamp = time_top -
+							(num_pattern * ext0_sip * cdata->fifo_output[ST_MASK_ID_EXT0].deltatime) - 300000;
+					else
+						cdata->fifo_output[ST_MASK_ID_EXT0].timestamp = time_top -
+							(num_pattern * ext0_sip * cdata->fifo_output[ST_MASK_ID_EXT0].deltatime) - 300000 -
+							(cdata->fifo_output[cdata->slower_id].deltatime - cdata->fifo_output[ST_MASK_ID_EXT0].deltatime);
+				} else
+					cdata->fifo_output[ST_MASK_ID_EXT0].timestamp += cdata->fifo_output[ST_MASK_ID_EXT0].deltatime;
+
+				if (cdata->fifo_output[ST_MASK_ID_EXT0].timestamp > time_top) {
+					cdata->fifo_output[ST_MASK_ID_EXT0].timestamp -= cdata->fifo_output[ST_MASK_ID_EXT0].deltatime;
+					cdata->samples_to_discard[ST_MASK_ID_EXT0] = 1;
+				}
+
+				if (cdata->samples_to_discard[ST_MASK_ID_EXT0] > 0)
+					cdata->samples_to_discard[ST_MASK_ID_EXT0]--;
+				else {
+					cdata->fifo_output[ST_MASK_ID_EXT0].num_samples++;
+
+					if (cdata->fifo_output[ST_MASK_ID_EXT0].num_samples >= cdata->fifo_output[ST_MASK_ID_EXT0].decimator) {
+						cdata->fifo_output[ST_MASK_ID_EXT0].num_samples = 0;
+
+						if (cdata->sensors_enabled & BIT(ST_MASK_ID_EXT0)) {
+							if (cdata->samples_to_discard_2[ST_MASK_ID_EXT0] == 0) {
+								err = st_lsm6ds3_push_data_with_timestamp(
+									cdata, ST_MASK_ID_EXT0,
+									&cdata->fifo_data[fifo_offset],
+									cdata->fifo_output[ST_MASK_ID_EXT0].timestamp);
+
+								if (err >= 0)
+									cdata->fifo_output[ST_MASK_ID_EXT0].initialized = true;
+
+								memcpy(cdata->ext0_last_push, &cdata->fifo_data[fifo_offset], 6);
+							} else {
+								cdata->samples_to_discard_2[ST_MASK_ID_EXT0]--;
+
+								if (cdata->fifo_output[ST_MASK_ID_EXT0].initialized) {
+									err = st_lsm6ds3_push_data_with_timestamp(
+										cdata, ST_MASK_ID_EXT0,
+										cdata->ext0_last_push,
+										cdata->fifo_output[ST_MASK_ID_EXT0].timestamp);
+								}
+							}
+						}
+					}
+				}
+
+				fifo_offset += ST_LSM6DS3_FIFO_ELEMENT_LEN_BYTE;
+				ext0_sip--;
+			}
+
+		} while ((accel_sip > 0) || (gyro_sip > 0) || (ext0_sip > 0));
+#else /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+		} while ((accel_sip > 0) || (gyro_sip > 0));
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+	}
+}
+
+int st_lsm6ds3_read_fifo(struct lsm6ds3_data *cdata, bool async)
+{
+	int err;
+	u8 fifo_status[2];
+	struct timespec ts;
+#if (CONFIG_ST_LSM6DS3_IIO_LIMIT_FIFO > 0)
+	u16 data_remaining, data_to_read;
+#endif /* CONFIG_ST_LSM6DS3_IIO_LIMIT_FIFO */
+	u16 read_len = 0, byte_in_pattern, num_pattern;
+	int64_t temp_counter = 0, timestamp_diff, slower_deltatime;
+
+	err = cdata->tf->read(cdata, ST_LSM6DS3_FIFO_DIFF_L,
+						2, fifo_status, true);
+	if (err < 0)
+		return err;
+
+	get_monotonic_boottime(&ts);
+	timestamp_diff = timespec_to_ns(&ts);
+
+	if (fifo_status[1] & ST_LSM6DS3_FIFO_DATA_OVR) {
+		st_lsm6ds3_set_fifo_mode(cdata, BYPASS);
+		st_lsm6ds3_set_fifo_mode(cdata, CONTINUOS);
+		dev_err(cdata->dev, "data fifo overrun, failed to read it.\n");
+		return -EINVAL;
+	}
+
+	if (fifo_status[1] & ST_LSM6DS3_FIFO_DATA_EMPTY)
+		return 0;
+
+	read_len = ((fifo_status[1] & ST_LSM6DS3_FIFO_DIFF_MASK) << 8) | fifo_status[0];
+	read_len *= ST_LSM6DS3_BYTE_FOR_CHANNEL;
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+	byte_in_pattern = (cdata->fifo_output[ST_MASK_ID_ACCEL].sip +
+				cdata->fifo_output[ST_MASK_ID_GYRO].sip +
+				cdata->fifo_output[ST_MASK_ID_EXT0].sip) *
+				ST_LSM6DS3_FIFO_ELEMENT_LEN_BYTE;
+#else /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+	byte_in_pattern = (cdata->fifo_output[ST_MASK_ID_ACCEL].sip +
+				cdata->fifo_output[ST_MASK_ID_GYRO].sip) *
+				ST_LSM6DS3_FIFO_ELEMENT_LEN_BYTE;
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+	if (byte_in_pattern == 0)
+		return 0;
+
+	num_pattern = read_len / byte_in_pattern;
+
+	read_len = (read_len / byte_in_pattern) * byte_in_pattern;
+	if (read_len == 0)
+		return 0;
+
+#if (CONFIG_ST_LSM6DS3_IIO_LIMIT_FIFO == 0)
+	err = cdata->tf->read(cdata, ST_LSM6DS3_FIFO_DATA_OUT_L,
+					read_len, cdata->fifo_data, true);
+	if (err < 0)
+		return err;
+#else /* CONFIG_ST_LSM6DS3_IIO_LIMIT_FIFO */
+	data_remaining = read_len;
+
+	do {
+		if (data_remaining > CONFIG_ST_LSM6DS3_IIO_LIMIT_FIFO)
+			data_to_read = CONFIG_ST_LSM6DS3_IIO_LIMIT_FIFO;
+		else
+			data_to_read = data_remaining;
+
+		err = cdata->tf->read(cdata, ST_LSM6DS3_FIFO_DATA_OUT_L,
+				data_to_read,
+				&cdata->fifo_data[read_len - data_remaining], true);
+		if (err < 0)
+			return err;
+
+		data_remaining -= data_to_read;
+	} while (data_remaining > 0);
+#endif /* CONFIG_ST_LSM6DS3_IIO_LIMIT_FIFO */
+
+	cdata->slower_id = MIN_ID(cdata->fifo_output[ST_MASK_ID_GYRO].sip,
+				cdata->fifo_output[ST_MASK_ID_ACCEL].sip,
+				ST_MASK_ID_GYRO, ST_MASK_ID_ACCEL);
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+	cdata->slower_id = MIN_ID(cdata->fifo_output[cdata->slower_id].sip,
+				cdata->fifo_output[ST_MASK_ID_EXT0].sip,
+				cdata->slower_id, ST_MASK_ID_EXT0);
+#endif /* CONFIG_ST_LSM6DS3_IIO_LIMIT_FIFO */
+
+	temp_counter = cdata->slower_counter;
+	cdata->slower_counter += (read_len / byte_in_pattern) * cdata->fifo_output[cdata->slower_id].sip;
+
+	if (async)
+		goto parse_fifo;
+
+	if (temp_counter > 0) {
+		slower_deltatime = div64_s64(timestamp_diff - cdata->fifo_enable_timestamp, cdata->slower_counter);
+
+		switch (cdata->slower_id) {
+		case ST_MASK_ID_ACCEL:
+			if (cdata->fifo_output[ST_MASK_ID_GYRO].sip != 0)
+				cdata->fifo_output[ST_MASK_ID_GYRO].deltatime = div64_s64(slower_deltatime *
+					cdata->fifo_output[ST_MASK_ID_ACCEL].sip, cdata->fifo_output[ST_MASK_ID_GYRO].sip);
+
+			if (cdata->fifo_output[ST_MASK_ID_EXT0].sip != 0)
+				cdata->fifo_output[ST_MASK_ID_EXT0].deltatime = div64_s64(slower_deltatime *
+					cdata->fifo_output[ST_MASK_ID_ACCEL].sip, cdata->fifo_output[ST_MASK_ID_EXT0].sip);
+
+			cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime = slower_deltatime;
+			break;
+
+		case ST_MASK_ID_GYRO:
+			if (cdata->fifo_output[ST_MASK_ID_ACCEL].sip != 0)
+				cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime = div64_s64(slower_deltatime *
+					cdata->fifo_output[ST_MASK_ID_GYRO].sip, cdata->fifo_output[ST_MASK_ID_ACCEL].sip);
+
+			if (cdata->fifo_output[ST_MASK_ID_EXT0].sip != 0)
+				cdata->fifo_output[ST_MASK_ID_EXT0].deltatime = div64_s64(slower_deltatime *
+					cdata->fifo_output[ST_MASK_ID_GYRO].sip, cdata->fifo_output[ST_MASK_ID_EXT0].sip);
+
+			cdata->fifo_output[ST_MASK_ID_GYRO].deltatime = slower_deltatime;
+			break;
+
+		case ST_MASK_ID_EXT0:
+			if (cdata->fifo_output[ST_MASK_ID_ACCEL].sip != 0)
+				cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime = div64_s64(slower_deltatime *
+					cdata->fifo_output[ST_MASK_ID_EXT0].sip, cdata->fifo_output[ST_MASK_ID_ACCEL].sip);
+
+			if (cdata->fifo_output[ST_MASK_ID_GYRO].sip != 0)
+				cdata->fifo_output[ST_MASK_ID_GYRO].deltatime = div64_s64(slower_deltatime *
+					cdata->fifo_output[ST_MASK_ID_EXT0].sip, cdata->fifo_output[ST_MASK_ID_GYRO].sip);
+
+			cdata->fifo_output[ST_MASK_ID_EXT0].deltatime = slower_deltatime;
+			break;
+
+		default:
+			break;
+		}
+	} else {
+		cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime = cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime_default;
+		cdata->fifo_output[ST_MASK_ID_GYRO].deltatime = cdata->fifo_output[ST_MASK_ID_GYRO].deltatime_default;
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+		cdata->fifo_output[ST_MASK_ID_EXT0].deltatime = cdata->fifo_output[ST_MASK_ID_EXT0].deltatime_default;
+#endif /* CONFIG_ST_LSM6DS3_IIO_LIMIT_FIFO */
+	}
+
+parse_fifo:
+	st_lsm6ds3_parse_fifo_data(cdata, read_len, timestamp_diff, num_pattern);
+
+	return 0;
+}
+
+int lsm6ds3_read_output_data(struct lsm6ds3_data *cdata, int sindex, bool push)
+{
+	int err;
+	u8 data[6];
+	struct iio_dev *indio_dev = cdata->indio_dev[sindex];
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = cdata->tf->read(cdata, sdata->data_out_reg,
+				ST_LSM6DS3_BYTE_FOR_CHANNEL * 3, data, true);
+	if (err < 0)
+		return err;
+
+	if (push)
+		st_lsm6ds3_push_data_with_timestamp(cdata, sindex,
+							data, cdata->timestamp);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm6ds3_read_output_data);
+
+static irqreturn_t st_lsm6ds3_outdata_trigger_handler(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+
+	iio_trigger_notify_done(indio_dev->trig);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t st_lsm6ds3_step_counter_trigger_handler(int irq, void *p)
+{
+	int err;
+	u8 steps_data[2];
+	struct timespec ts;
+	int64_t timestamp = 0;
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	if (!sdata->cdata->reset_steps) {
+		err = sdata->cdata->tf->read(sdata->cdata,
+					(u8)indio_dev->channels[0].address,
+					ST_LSM6DS3_BYTE_FOR_CHANNEL,
+					steps_data, true);
+		if (err < 0)
+			goto st_lsm6ds3_step_counter_done;
+
+		sdata->cdata->num_steps = (sdata->cdata->num_steps &
+			ST_LSM6DS3_STEP_MASK_64BIT) + *((u16 *)steps_data);
+		timestamp = sdata->cdata->timestamp;
+	} else {
+		sdata->cdata->num_steps = 0;
+		get_monotonic_boottime(&ts);
+		timestamp = timespec_to_ns(&ts);
+		sdata->cdata->reset_steps = false;
+	}
+
+	memcpy(sdata->buffer_data, (u8 *)&sdata->cdata->num_steps, sizeof(u64));
+
+	if (indio_dev->scan_timestamp)
+		*(s64 *)((u8 *)sdata->buffer_data +
+				ALIGN(ST_LSM6DS3_BYTE_FOR_CHANNEL,
+						sizeof(s64))) = timestamp;
+
+	iio_push_to_buffers(indio_dev, sdata->buffer_data);
+
+st_lsm6ds3_step_counter_done:
+	iio_trigger_notify_done(indio_dev->trig);
+	return IRQ_HANDLED;
+}
+
+static inline irqreturn_t st_lsm6ds3_handler_empty(int irq, void *p)
+{
+	return IRQ_HANDLED;
+}
+
+int st_lsm6ds3_trig_set_state(struct iio_trigger *trig, bool state)
+{
+	return 0;
+}
+
+static int st_lsm6ds3_buffer_preenable(struct iio_dev *indio_dev)
+{
+#ifdef CONFIG_ST_LSM6DS3_XL_DATA_INJECTION
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	if (sdata->cdata->injection_mode) {
+		switch (sdata->sindex) {
+		case ST_MASK_ID_ACCEL:
+		case ST_MASK_ID_GYRO:
+			return -EBUSY;
+
+		default:
+			break;
+		}
+	}
+#endif /* CONFIG_ST_LSM6DS3_XL_DATA_INJECTION */
+
+	return 0;
+}
+
+static int st_lsm6ds3_buffer_postenable(struct iio_dev *indio_dev)
+{
+	int err;
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	sdata->cdata->fifo_output[sdata->sindex].initialized = false;
+
+	if ((sdata->cdata->hwfifo_enabled[sdata->sindex]) &&
+		(indio_dev->buffer->length < 2 * ST_LSM6DS3_MAX_FIFO_LENGHT))
+		return -EINVAL;
+
+	err = iio_triggered_buffer_postenable(indio_dev);
+	if (err < 0)
+		return err;
+
+	sdata->buffer_data = kmalloc(indio_dev->scan_bytes, GFP_KERNEL);
+	if (!sdata->buffer_data)
+		return -ENOMEM;
+
+	mutex_lock(&sdata->cdata->odr_lock);
+
+	err = st_lsm6ds3_set_enable(sdata, true, true);
+	if (err < 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return err;
+	}
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+
+	if (sdata->sindex == ST_MASK_ID_STEP_COUNTER)
+		iio_trigger_poll_chained(sdata->cdata->trig[ST_MASK_ID_STEP_COUNTER]);
+
+	if (sdata->sindex == ST_MASK_ID_SIGN_MOTION)
+		sdata->cdata->sign_motion_event_ready = true;
+
+	return 0;
+}
+
+static int st_lsm6ds3_buffer_predisable(struct iio_dev *indio_dev)
+{
+	return iio_triggered_buffer_predisable(indio_dev);
+}
+
+static int st_lsm6ds3_buffer_postdisable(struct iio_dev *indio_dev)
+{
+	int err;
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	if (sdata->sindex == ST_MASK_ID_SIGN_MOTION)
+		sdata->cdata->sign_motion_event_ready = false;
+
+	mutex_lock(&sdata->cdata->odr_lock);
+
+	err = st_lsm6ds3_set_enable(sdata, false, true);
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+
+	kfree(sdata->buffer_data);
+
+	return err < 0 ? err : 0;
+}
+
+static const struct iio_buffer_setup_ops st_lsm6ds3_buffer_setup_ops = {
+	.preenable = &st_lsm6ds3_buffer_preenable,
+	.postenable = &st_lsm6ds3_buffer_postenable,
+	.predisable = &st_lsm6ds3_buffer_predisable,
+	.postdisable = &st_lsm6ds3_buffer_postdisable,
+};
+
+int st_lsm6ds3_allocate_rings(struct lsm6ds3_data *cdata)
+{
+	int err;
+	struct lsm6ds3_sensor_data *sdata;
+
+	sdata = iio_priv(cdata->indio_dev[ST_MASK_ID_ACCEL]);
+
+	err = iio_triggered_buffer_setup(cdata->indio_dev[ST_MASK_ID_ACCEL],
+				NULL, &st_lsm6ds3_outdata_trigger_handler,
+				&st_lsm6ds3_buffer_setup_ops);
+	if (err < 0)
+		return err;
+
+	sdata = iio_priv(cdata->indio_dev[ST_MASK_ID_GYRO]);
+
+	err = iio_triggered_buffer_setup(cdata->indio_dev[ST_MASK_ID_GYRO],
+				NULL, &st_lsm6ds3_outdata_trigger_handler,
+				&st_lsm6ds3_buffer_setup_ops);
+	if (err < 0)
+		goto buffer_cleanup_accel;
+
+	err = iio_triggered_buffer_setup(
+				cdata->indio_dev[ST_MASK_ID_SIGN_MOTION],
+				&st_lsm6ds3_handler_empty, NULL,
+				&st_lsm6ds3_buffer_setup_ops);
+	if (err < 0)
+		goto buffer_cleanup_gyro;
+
+	err = iio_triggered_buffer_setup(
+				cdata->indio_dev[ST_MASK_ID_STEP_COUNTER],
+				NULL,
+				&st_lsm6ds3_step_counter_trigger_handler,
+				&st_lsm6ds3_buffer_setup_ops);
+	if (err < 0)
+		goto buffer_cleanup_sign_motion;
+
+	err = iio_triggered_buffer_setup(
+				cdata->indio_dev[ST_MASK_ID_STEP_DETECTOR],
+				&st_lsm6ds3_handler_empty, NULL,
+				&st_lsm6ds3_buffer_setup_ops);
+	if (err < 0)
+		goto buffer_cleanup_step_counter;
+
+	err = iio_triggered_buffer_setup(
+				cdata->indio_dev[ST_MASK_ID_TILT],
+				&st_lsm6ds3_handler_empty, NULL,
+				&st_lsm6ds3_buffer_setup_ops);
+	if (err < 0)
+		goto buffer_cleanup_step_detector;
+
+	return 0;
+
+buffer_cleanup_step_detector:
+	iio_triggered_buffer_cleanup(
+				cdata->indio_dev[ST_MASK_ID_STEP_DETECTOR]);
+buffer_cleanup_step_counter:
+	iio_triggered_buffer_cleanup(
+				cdata->indio_dev[ST_MASK_ID_STEP_COUNTER]);
+buffer_cleanup_sign_motion:
+	iio_triggered_buffer_cleanup(
+				cdata->indio_dev[ST_MASK_ID_SIGN_MOTION]);
+buffer_cleanup_gyro:
+	iio_triggered_buffer_cleanup(cdata->indio_dev[ST_MASK_ID_GYRO]);
+buffer_cleanup_accel:
+	iio_triggered_buffer_cleanup(cdata->indio_dev[ST_MASK_ID_ACCEL]);
+	return err;
+}
+
+void st_lsm6ds3_deallocate_rings(struct lsm6ds3_data *cdata)
+{
+	iio_triggered_buffer_cleanup(cdata->indio_dev[ST_MASK_ID_TILT]);
+	iio_triggered_buffer_cleanup(
+				cdata->indio_dev[ST_MASK_ID_STEP_DETECTOR]);
+	iio_triggered_buffer_cleanup(
+				cdata->indio_dev[ST_MASK_ID_STEP_COUNTER]);
+	iio_triggered_buffer_cleanup(
+				cdata->indio_dev[ST_MASK_ID_SIGN_MOTION]);
+	iio_triggered_buffer_cleanup(cdata->indio_dev[ST_MASK_ID_ACCEL]);
+	iio_triggered_buffer_cleanup(cdata->indio_dev[ST_MASK_ID_GYRO]);
+}
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics lsm6ds3 buffer driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_core.c b/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_core.c
new file mode 100755
index 0000000..e8becf3
--- /dev/null
+++ b/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_core.c
@@ -0,0 +1,3171 @@
+/*
+ * STMicroelectronics lsm6ds3 core driver
+ *
+ * Copyright 2014-2016 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/irq.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/events.h>
+#include <asm/unaligned.h>
+
+#include <linux/iio/common/st_sensors.h>
+#include "st_lsm6ds3.h"
+
+#define MS_TO_NS(msec)				((msec) * 1000 * 1000)
+
+#ifndef MAX
+#define MAX(a, b)				(((a) > (b)) ? (a) : (b))
+#endif
+
+#ifndef MIN
+#define MIN(a, b)				(((a) < (b)) ? (a) : (b))
+#endif
+
+#define MIN_BNZ(a, b)				(((a) < (b)) ? ((a == 0) ? \
+						(b) : (a)) : ((b == 0) ? \
+						(a) : (b)))
+
+/* COMMON VALUES FOR ACCEL-GYRO SENSORS */
+#define ST_LSM6DS3_WAI_ADDRESS			0x0f
+#define ST_LSM6DS3_WAI_EXP			0x69
+#define ST_LSM6DS3_INT1_ADDR			0x0d
+#define ST_LSM6DS3_INT2_ADDR			0x0e
+#define ST_LSM6DS3_ACCEL_DRDY_IRQ_MASK		0x01
+#define ST_LSM6DS3_GYRO_DRDY_IRQ_MASK		0x02
+#define ST_LSM6DS3_MD1_ADDR			0x5e
+#define ST_LSM6DS3_ODR_LIST_NUM			6
+#define ST_LSM6DS3_ODR_POWER_OFF_VAL		0x00
+#define ST_LSM6DS3_ODR_13HZ_VAL			0x01
+#define ST_LSM6DS3_ODR_26HZ_VAL			0x02
+#define ST_LSM6DS3_ODR_52HZ_VAL			0x03
+#define ST_LSM6DS3_ODR_104HZ_VAL		0x04
+#define ST_LSM6DS3_ODR_208HZ_VAL		0x05
+#define ST_LSM6DS3_ODR_416HZ_VAL		0x06
+#define ST_LSM6DS3_FS_LIST_NUM			4
+#define ST_LSM6DS3_BDU_ADDR			0x12
+#define ST_LSM6DS3_BDU_MASK			0x40
+#define ST_LSM6DS3_EN_BIT			0x01
+#define ST_LSM6DS3_DIS_BIT			0x00
+#define ST_LSM6DS3_FUNC_EN_ADDR			0x19
+#define ST_LSM6DS3_FUNC_EN_MASK			0x04
+#define ST_LSM6DS3_FUNC_CFG_ACCESS_ADDR		0x01
+#define ST_LSM6DS3_FUNC_CFG_ACCESS_MASK		0x01
+#define ST_LSM6DS3_FUNC_CFG_ACCESS_MASK2	0x04
+#define ST_LSM6DS3_FUNC_CFG_REG2_MASK		0x80
+#define ST_LSM6DS3_FUNC_CFG_START1_ADDR		0x62
+#define ST_LSM6DS3_FUNC_CFG_START2_ADDR		0x63
+#define ST_LSM6DS3_SENSORHUB_ADDR		0x1a
+#define ST_LSM6DS3_SENSORHUB_MASK		0x01
+#define ST_LSM6DS3_SENSORHUB_TRIG_MASK		0x10
+#define ST_LSM6DS3_TRIG_INTERNAL		0x00
+#define ST_LSM6DS3_TRIG_EXTERNAL		0x01
+#define ST_LSM6DS3_SELFTEST_ADDR		0x14
+#define ST_LSM6DS3_SELFTEST_ACCEL_MASK		0x03
+#define ST_LSM6DS3_SELFTEST_GYRO_MASK		0x0c
+#define ST_LSM6DS3_SELF_TEST_DISABLED_VAL	0x00
+#define ST_LSM6DS3_SELF_TEST_POS_SIGN_VAL	0x01
+#define ST_LSM6DS3_SELF_TEST_NEG_ACCEL_SIGN_VAL	0x02
+#define ST_LSM6DS3_SELF_TEST_NEG_GYRO_SIGN_VAL	0x03
+#define ST_LSM6DS3_LIR_ADDR			0x58
+#define ST_LSM6DS3_LIR_MASK			0x01
+#define ST_LSM6DS3_TIMER_EN_ADDR		0x58
+#define ST_LSM6DS3_TIMER_EN_MASK		0x80
+#define ST_LSM6DS3_PEDOMETER_EN_ADDR		0x58
+#define ST_LSM6DS3_PEDOMETER_EN_MASK		0x40
+#define ST_LSM6DS3_INT2_ON_INT1_ADDR		0x13
+#define ST_LSM6DS3_INT2_ON_INT1_MASK		0x20
+#define ST_LSM6DS3_MIN_DURATION_MS		1638
+#define ST_LSM6DS3_ROUNDING_ADDR		0x16
+#define ST_LSM6DS3_ROUNDING_MASK		0x04
+#define ST_LSM6DS3_FIFO_MODE_ADDR		0x0a
+#define ST_LSM6DS3_FIFO_MODE_MASK		0x07
+#define ST_LSM6DS3_FIFO_MODE_BYPASS		0x00
+#define ST_LSM6DS3_FIFO_MODE_CONTINUOS		0x06
+#define ST_LSM6DS3_FIFO_THRESHOLD_IRQ_MASK	0x08
+#define ST_LSM6DS3_FIFO_ODR_MAX			0x40
+#define ST_LSM6DS3_FIFO_DECIMATOR_ADDR		0x08
+#define ST_LSM6DS3_FIFO_ACCEL_DECIMATOR_MASK	0x07
+#define ST_LSM6DS3_FIFO_GYRO_DECIMATOR_MASK	0x38
+#define ST_LSM6DS3_FIFO_DECIMATOR2_ADDR		0x09
+#define ST_LSM6DS3_FIFO_THR_L_ADDR		0x06
+#define ST_LSM6DS3_FIFO_THR_H_ADDR		0x07
+#define ST_LSM6DS3_FIFO_THR_MASK		0x0fff
+#define ST_LSM6DS3_FIFO_THR_IRQ_MASK		0x08
+#define ST_LSM6DS3_RESET_ADDR			0x12
+#define ST_LSM6DS3_RESET_MASK			0x01
+#define ST_LSM6DS3_TEST_REG_ADDR		0x00
+#define ST_LSM6DS3_START_INJECT_XL_MASK		0x08
+#define ST_LSM6DS3_INJECT_XL_X_ADDR		0x06
+#define ST_LSM6DS3_NS_AT_25HZ			40000000LL
+#define ST_LSM6DS3_26HZ_NS			(38461538LL)
+#define ST_LSM6DS3_SELFTEST_NA_MS		"na"
+#define ST_LSM6DS3_SELFTEST_FAIL_MS		"fail"
+#define ST_LSM6DS3_SELFTEST_PASS_MS		"pass"
+
+/* CUSTOM VALUES FOR ACCEL SENSOR */
+#define ST_LSM6DS3_ACCEL_ODR_ADDR		0x10
+#define ST_LSM6DS3_ACCEL_ODR_MASK		0xf0
+#define ST_LSM6DS3_ACCEL_FS_ADDR		0x10
+#define ST_LSM6DS3_ACCEL_FS_MASK		0x0c
+#define ST_LSM6DS3_ACCEL_FS_2G_VAL		0x00
+#define ST_LSM6DS3_ACCEL_FS_4G_VAL		0x02
+#define ST_LSM6DS3_ACCEL_FS_8G_VAL		0x03
+#define ST_LSM6DS3_ACCEL_FS_16G_VAL		0x01
+#define ST_LSM6DS3_ACCEL_FS_2G_GAIN		IIO_G_TO_M_S_2(61)
+#define ST_LSM6DS3_ACCEL_FS_4G_GAIN		IIO_G_TO_M_S_2(122)
+#define ST_LSM6DS3_ACCEL_FS_8G_GAIN		IIO_G_TO_M_S_2(244)
+#define ST_LSM6DS3_ACCEL_FS_16G_GAIN		IIO_G_TO_M_S_2(488)
+#define ST_LSM6DS3_ACCEL_OUT_X_L_ADDR		0x28
+#define ST_LSM6DS3_ACCEL_OUT_Y_L_ADDR		0x2a
+#define ST_LSM6DS3_ACCEL_OUT_Z_L_ADDR		0x2c
+#define ST_LSM6DS3_ACCEL_STD_52HZ		1
+#define ST_LSM6DS3_ACCEL_STD_104HZ		2
+#define ST_LSM6DS3_ACCEL_STD_208HZ		3
+#define ST_LSM6DS3_SELFTEST_ACCEL_ADDR		0x10
+#define ST_LSM6DS3_SELFTEST_ACCEL_REG_VALUE	0x40
+#define ST_LSM6DS3_SELFTEST_ACCEL_MIN		1492
+#define ST_LSM6DS3_SELFTEST_ACCEL_MAX		27868
+
+/* CUSTOM VALUES FOR GYRO SENSOR */
+#define ST_LSM6DS3_GYRO_ODR_ADDR		0x11
+#define ST_LSM6DS3_GYRO_ODR_MASK		0xf0
+#define ST_LSM6DS3_GYRO_FS_ADDR			0x11
+#define ST_LSM6DS3_GYRO_FS_MASK			0x0c
+#define ST_LSM6DS3_GYRO_FS_250_VAL		0x00
+#define ST_LSM6DS3_GYRO_FS_500_VAL		0x01
+#define ST_LSM6DS3_GYRO_FS_1000_VAL		0x02
+#define ST_LSM6DS3_GYRO_FS_2000_VAL		0x03
+#define ST_LSM6DS3_GYRO_FS_250_GAIN		IIO_DEGREE_TO_RAD(8750)
+#define ST_LSM6DS3_GYRO_FS_500_GAIN		IIO_DEGREE_TO_RAD(17500)
+#define ST_LSM6DS3_GYRO_FS_1000_GAIN		IIO_DEGREE_TO_RAD(35000)
+#define ST_LSM6DS3_GYRO_FS_2000_GAIN		IIO_DEGREE_TO_RAD(70000)
+#define ST_LSM6DS3_GYRO_OUT_X_L_ADDR		0x22
+#define ST_LSM6DS3_GYRO_OUT_Y_L_ADDR		0x24
+#define ST_LSM6DS3_GYRO_OUT_Z_L_ADDR		0x26
+#define ST_LSM6DS3_GYRO_STD_13HZ		2
+#define ST_LSM6DS3_GYRO_STD_52HZ		3
+#define ST_LSM6DS3_GYRO_STD_104HZ		5
+#define ST_LSM6DS3_GYRO_STD_208HZ		8
+#define ST_LSM6DS3_SELFTEST_GYRO_ADDR		0x11
+#define ST_LSM6DS3_SELFTEST_GYRO_REG_VALUE	0x4c
+#define ST_LSM6DS3_SELFTEST_GYRO_MIN		2142
+#define ST_LSM6DS3_SELFTEST_GYRO_MAX		10000
+
+/* CUSTOM VALUES FOR SIGNIFICANT MOTION SENSOR */
+#define ST_LSM6DS3_SIGN_MOTION_EN_ADDR		0x19
+#define ST_LSM6DS3_SIGN_MOTION_EN_MASK		0x01
+
+/* CUSTOM VALUES FOR STEP DETECTOR SENSOR */
+#define ST_LSM6DS3_STEP_DETECTOR_DRDY_IRQ_MASK	0x80
+
+/* CUSTOM VALUES FOR STEP COUNTER SENSOR */
+#define ST_LSM6DS3_STEP_COUNTER_DRDY_IRQ_MASK	0x80
+#define ST_LSM6DS3_STEP_COUNTER_OUT_L_ADDR	0x4b
+#define ST_LSM6DS3_STEP_COUNTER_RES_ADDR	0x19
+#define ST_LSM6DS3_STEP_COUNTER_RES_MASK	0x06
+#define ST_LSM6DS3_STEP_COUNTER_RES_ALL_EN	0x03
+#define ST_LSM6DS3_STEP_COUNTER_RES_FUNC_EN	0x02
+#define ST_LSM6DS3_STEP_COUNTER_DURATION_ADDR	0x15
+#define ST_LSM6DS3_STEP_COUNTER_THS_ADDR	0x0f
+#define ST_LSM6DS3_STEP_COUNTER_THS_2G_VALUE	(0x00 | 0x10)
+#define ST_LSM6DS3_STEP_COUNTER_THS_4G_VALUE	(0x80 | 0x08)
+
+/* CUSTOM VALUES FOR TILT SENSOR */
+#define ST_LSM6DS3_TILT_EN_ADDR			0x58
+#define ST_LSM6DS3_TILT_EN_MASK			0x20
+#define ST_LSM6DS3_TILT_DRDY_IRQ_MASK		0x02
+
+#define ST_LSM6DS3_ACCEL_SUFFIX_NAME		"accel"
+#define ST_LSM6DS3_GYRO_SUFFIX_NAME		"gyro"
+#define ST_LSM6DS3_STEP_COUNTER_SUFFIX_NAME	"step_c"
+#define ST_LSM6DS3_STEP_DETECTOR_SUFFIX_NAME	"step_d"
+#define ST_LSM6DS3_SIGN_MOTION_SUFFIX_NAME	"sign_motion"
+#define ST_LSM6DS3_TILT_SUFFIX_NAME		"tilt"
+
+#define ST_LSM6DS3_DEV_ATTR_SAMP_FREQ() \
+		IIO_DEV_ATTR_SAMP_FREQ(S_IWUSR | S_IRUGO, \
+			st_lsm6ds3_sysfs_get_sampling_frequency, \
+			st_lsm6ds3_sysfs_set_sampling_frequency)
+
+#define ST_LSM6DS3_DEV_ATTR_SAMP_FREQ_AVAIL() \
+		IIO_DEV_ATTR_SAMP_FREQ_AVAIL( \
+			st_lsm6ds3_sysfs_sampling_frequency_avail)
+
+#define ST_LSM6DS3_DEV_ATTR_SCALE_AVAIL(name) \
+		IIO_DEVICE_ATTR(name, S_IRUGO, \
+			st_lsm6ds3_sysfs_scale_avail, NULL , 0);
+
+static struct st_lsm6ds3_selftest_table {
+	char *string_mode;
+	u8 accel_value;
+	u8 gyro_value;
+	u8 gyro_mask;
+} st_lsm6ds3_selftest_table[] = {
+	[0] = {
+		.string_mode = "disabled",
+		.accel_value = ST_LSM6DS3_SELF_TEST_DISABLED_VAL,
+		.gyro_value = ST_LSM6DS3_SELF_TEST_DISABLED_VAL,
+	},
+	[1] = {
+		.string_mode = "positive-sign",
+		.accel_value = ST_LSM6DS3_SELF_TEST_POS_SIGN_VAL,
+		.gyro_value = ST_LSM6DS3_SELF_TEST_POS_SIGN_VAL
+	},
+	[2] = {
+		.string_mode = "negative-sign",
+		.accel_value = ST_LSM6DS3_SELF_TEST_NEG_ACCEL_SIGN_VAL,
+		.gyro_value = ST_LSM6DS3_SELF_TEST_NEG_GYRO_SIGN_VAL
+	},
+};
+
+struct st_lsm6ds3_odr_reg {
+	unsigned int hz;
+	u8 value;
+};
+
+static struct st_lsm6ds3_odr_table {
+	u8 addr[2];
+	u8 mask[2];
+	struct st_lsm6ds3_odr_reg odr_avl[ST_LSM6DS3_ODR_LIST_NUM];
+} st_lsm6ds3_odr_table = {
+	.addr[ST_MASK_ID_ACCEL] = ST_LSM6DS3_ACCEL_ODR_ADDR,
+	.mask[ST_MASK_ID_ACCEL] = ST_LSM6DS3_ACCEL_ODR_MASK,
+	.addr[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_ODR_ADDR,
+	.mask[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_ODR_MASK,
+	.odr_avl[0] = { .hz = 13, .value = ST_LSM6DS3_ODR_13HZ_VAL },
+	.odr_avl[1] = { .hz = 26, .value = ST_LSM6DS3_ODR_26HZ_VAL },
+	.odr_avl[2] = { .hz = 52, .value = ST_LSM6DS3_ODR_52HZ_VAL },
+	.odr_avl[3] = { .hz = 104, .value = ST_LSM6DS3_ODR_104HZ_VAL },
+	.odr_avl[4] = { .hz = 208, .value = ST_LSM6DS3_ODR_208HZ_VAL },
+	.odr_avl[5] = { .hz = 416, .value = ST_LSM6DS3_ODR_416HZ_VAL },
+};
+
+struct st_lsm6ds3_fs_reg {
+	unsigned int gain;
+	u8 value;
+};
+
+static struct st_lsm6ds3_fs_table {
+	u8 addr;
+	u8 mask;
+	struct st_lsm6ds3_fs_reg fs_avl[ST_LSM6DS3_FS_LIST_NUM];
+} st_lsm6ds3_fs_table[ST_INDIO_DEV_NUM] = {
+	[ST_MASK_ID_ACCEL] = {
+		.addr = ST_LSM6DS3_ACCEL_FS_ADDR,
+		.mask = ST_LSM6DS3_ACCEL_FS_MASK,
+		.fs_avl[0] = { .gain = ST_LSM6DS3_ACCEL_FS_2G_GAIN,
+					.value = ST_LSM6DS3_ACCEL_FS_2G_VAL },
+		.fs_avl[1] = { .gain = ST_LSM6DS3_ACCEL_FS_4G_GAIN,
+					.value = ST_LSM6DS3_ACCEL_FS_4G_VAL },
+		.fs_avl[2] = { .gain = ST_LSM6DS3_ACCEL_FS_8G_GAIN,
+					.value = ST_LSM6DS3_ACCEL_FS_8G_VAL },
+		.fs_avl[3] = { .gain = ST_LSM6DS3_ACCEL_FS_16G_GAIN,
+					.value = ST_LSM6DS3_ACCEL_FS_16G_VAL },
+	},
+	[ST_MASK_ID_GYRO] = {
+		.addr = ST_LSM6DS3_GYRO_FS_ADDR,
+		.mask = ST_LSM6DS3_GYRO_FS_MASK,
+		.fs_avl[0] = { .gain = ST_LSM6DS3_GYRO_FS_250_GAIN,
+					.value = ST_LSM6DS3_GYRO_FS_250_VAL },
+		.fs_avl[1] = { .gain = ST_LSM6DS3_GYRO_FS_500_GAIN,
+					.value = ST_LSM6DS3_GYRO_FS_500_VAL },
+		.fs_avl[2] = { .gain = ST_LSM6DS3_GYRO_FS_1000_GAIN,
+					.value = ST_LSM6DS3_GYRO_FS_1000_VAL },
+		.fs_avl[3] = { .gain = ST_LSM6DS3_GYRO_FS_2000_GAIN,
+					.value = ST_LSM6DS3_GYRO_FS_2000_VAL },
+	}
+};
+
+static const struct iio_event_spec singol_thr_event = {
+	.type = IIO_EV_TYPE_THRESH,
+	.dir = IIO_EV_DIR_RISING,
+};
+
+const struct iio_event_spec lsm6ds3_fifo_flush_event = {
+	.type = IIO_EV_TYPE_FIFO_FLUSH,
+	.dir = IIO_EV_DIR_EITHER,
+};
+
+static const struct iio_chan_spec st_lsm6ds3_accel_ch[] = {
+	ST_LSM6DS3_LSM_CHANNELS(IIO_ACCEL, 1, 0, IIO_MOD_X, IIO_LE,
+				16, 16, ST_LSM6DS3_ACCEL_OUT_X_L_ADDR, 's'),
+	ST_LSM6DS3_LSM_CHANNELS(IIO_ACCEL, 1, 1, IIO_MOD_Y, IIO_LE,
+				16, 16, ST_LSM6DS3_ACCEL_OUT_Y_L_ADDR, 's'),
+	ST_LSM6DS3_LSM_CHANNELS(IIO_ACCEL, 1, 2, IIO_MOD_Z, IIO_LE,
+				16, 16, ST_LSM6DS3_ACCEL_OUT_Z_L_ADDR, 's'),
+	ST_LSM6DS3_FLUSH_CHANNEL(IIO_ACCEL),
+	IIO_CHAN_SOFT_TIMESTAMP(3)
+};
+
+static const struct iio_chan_spec st_lsm6ds3_gyro_ch[] = {
+	ST_LSM6DS3_LSM_CHANNELS(IIO_ANGL_VEL, 1, 0, IIO_MOD_X, IIO_LE,
+				16, 16, ST_LSM6DS3_GYRO_OUT_X_L_ADDR, 's'),
+	ST_LSM6DS3_LSM_CHANNELS(IIO_ANGL_VEL, 1, 1, IIO_MOD_Y, IIO_LE,
+				16, 16, ST_LSM6DS3_GYRO_OUT_Y_L_ADDR, 's'),
+	ST_LSM6DS3_LSM_CHANNELS(IIO_ANGL_VEL, 1, 2, IIO_MOD_Z, IIO_LE,
+				16, 16, ST_LSM6DS3_GYRO_OUT_Z_L_ADDR, 's'),
+	ST_LSM6DS3_FLUSH_CHANNEL(IIO_ANGL_VEL),
+	IIO_CHAN_SOFT_TIMESTAMP(3)
+};
+
+static const struct iio_chan_spec st_lsm6ds3_sign_motion_ch[] = {
+	{
+		.type = IIO_SIGN_MOTION,
+		.channel = 0,
+		.modified = 0,
+		.event_spec = &singol_thr_event,
+		.num_event_specs = 1,
+	},
+	IIO_CHAN_SOFT_TIMESTAMP(1)
+};
+
+static const struct iio_chan_spec st_lsm6ds3_step_c_ch[] = {
+	{
+		.type = IIO_STEP_COUNTER,
+		.modified = 0,
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
+		.address = ST_LSM6DS3_STEP_COUNTER_OUT_L_ADDR,
+		.scan_type = {
+			.sign = 'u',
+			.realbits = 64,
+			.storagebits = 64,
+			.endianness = IIO_LE,
+		},
+	},
+	ST_LSM6DS3_FLUSH_CHANNEL(IIO_STEP_COUNTER),
+	IIO_CHAN_SOFT_TIMESTAMP(1)
+};
+
+static const struct iio_chan_spec st_lsm6ds3_step_d_ch[] = {
+	ST_LSM6DS3_FLUSH_CHANNEL(IIO_STEP_DETECTOR),
+	IIO_CHAN_SOFT_TIMESTAMP(0)
+};
+
+static const struct iio_chan_spec st_lsm6ds3_tilt_ch[] = {
+	ST_LSM6DS3_FLUSH_CHANNEL(IIO_TILT),
+	IIO_CHAN_SOFT_TIMESTAMP(0)
+};
+
+
+int st_lsm6ds3_write_data_with_mask(struct lsm6ds3_data *cdata,
+				u8 reg_addr, u8 mask, u8 data, bool b_lock)
+{
+	int err;
+	u8 new_data = 0x00, old_data = 0x00;
+
+	err = cdata->tf->read(cdata, reg_addr, 1, &old_data, b_lock);
+	if (err < 0)
+		return err;
+
+	new_data = ((old_data & (~mask)) | ((data << __ffs(mask)) & mask));
+
+	if (new_data == old_data)
+		return 1;
+
+	return cdata->tf->write(cdata, reg_addr, 1, &new_data, b_lock);
+}
+EXPORT_SYMBOL(st_lsm6ds3_write_data_with_mask);
+
+static inline int st_lsm6ds3_enable_embedded_page_regs(struct lsm6ds3_data *cdata, bool enable)
+{
+	u8 value = 0x00;
+
+	if (enable)
+		value = ST_LSM6DS3_FUNC_CFG_REG2_MASK;
+
+	return cdata->tf->write(cdata, ST_LSM6DS3_FUNC_CFG_ACCESS_ADDR, 1, &value, false);
+}
+
+int st_lsm6ds3_write_embedded_registers(struct lsm6ds3_data *cdata,
+						u8 reg_addr, u8 *data, int len)
+{
+	int err = 0, err2, count = 0;
+
+	mutex_lock(&cdata->bank_registers_lock);
+
+	if (cdata->enable_digfunc_mask) {
+		err = st_lsm6ds3_write_data_with_mask(cdata,
+					ST_LSM6DS3_FUNC_EN_ADDR,
+					ST_LSM6DS3_FUNC_EN_MASK,
+					ST_LSM6DS3_DIS_BIT, false);
+		if (err < 0) {
+			mutex_unlock(&cdata->bank_registers_lock);
+			return err;
+		}
+	}
+
+	udelay(100);
+
+	err = st_lsm6ds3_enable_embedded_page_regs(cdata, true);
+	if (err < 0)
+		goto restore_digfunc;
+
+	udelay(100);
+
+	err = cdata->tf->write(cdata, reg_addr, len, data, false);
+	if (err < 0)
+		goto restore_bank_regs;
+
+	err = st_lsm6ds3_enable_embedded_page_regs(cdata, false);
+	if (err < 0)
+		goto restore_digfunc;
+
+	udelay(100);
+
+	if (cdata->enable_digfunc_mask) {
+		err = st_lsm6ds3_write_data_with_mask(cdata,
+					ST_LSM6DS3_FUNC_EN_ADDR,
+					ST_LSM6DS3_FUNC_EN_MASK,
+					ST_LSM6DS3_EN_BIT, false);
+		if (err < 0)
+			goto restore_digfunc;
+	}
+
+	mutex_unlock(&cdata->bank_registers_lock);
+
+	return 0;
+
+restore_bank_regs:
+	do {
+		msleep(200);
+		err2 = st_lsm6ds3_enable_embedded_page_regs(cdata, false);
+	} while ((err2 < 0) && (count++ < 10));
+
+	if (count >= 10)
+		pr_err("not able to close embedded page registers. It make driver unstable!\n");
+
+restore_digfunc:
+	if (cdata->enable_digfunc_mask) {
+		err2 = st_lsm6ds3_write_data_with_mask(cdata,
+					ST_LSM6DS3_FUNC_EN_ADDR,
+					ST_LSM6DS3_FUNC_EN_MASK,
+					ST_LSM6DS3_EN_BIT, false);
+	}
+
+	mutex_unlock(&cdata->bank_registers_lock);
+
+	return err;
+
+}
+
+static int lsm6ds3_set_watermark(struct lsm6ds3_data *cdata)
+{
+	int err;
+	u8 reg_value = 0;
+	u16 fifo_watermark;
+	unsigned int fifo_len, sip = 0, min_pattern = UINT_MAX;
+
+	if (cdata->fifo_output[ST_MASK_ID_ACCEL].sip > 0) {
+		sip += cdata->fifo_output[ST_MASK_ID_ACCEL].sip;
+		min_pattern = MIN(min_pattern,
+			cdata->hwfifo_watermark[ST_MASK_ID_ACCEL] /
+			cdata->fifo_output[ST_MASK_ID_ACCEL].sip);
+	}
+
+	if (cdata->fifo_output[ST_MASK_ID_GYRO].sip > 0) {
+		sip += cdata->fifo_output[ST_MASK_ID_GYRO].sip;
+		min_pattern = MIN(min_pattern,
+			cdata->hwfifo_watermark[ST_MASK_ID_GYRO] /
+			cdata->fifo_output[ST_MASK_ID_GYRO].sip);
+	}
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+	if (cdata->fifo_output[ST_MASK_ID_EXT0].sip > 0) {
+		sip += cdata->fifo_output[ST_MASK_ID_EXT0].sip;
+		min_pattern = MIN(min_pattern,
+			cdata->hwfifo_watermark[ST_MASK_ID_EXT0] /
+			cdata->fifo_output[ST_MASK_ID_EXT0].sip);
+	}
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+
+	if (sip == 0)
+		return 0;
+
+	if (min_pattern == 0)
+		min_pattern = 1;
+
+	min_pattern = MIN(min_pattern, ((unsigned int)ST_LSM6DS3_MAX_FIFO_THRESHOLD / sip));
+
+	fifo_len = min_pattern * sip * ST_LSM6DS3_FIFO_ELEMENT_LEN_BYTE;
+	fifo_watermark = (fifo_len / 2);
+
+	if (fifo_watermark < (ST_LSM6DS3_FIFO_ELEMENT_LEN_BYTE / 2))
+		fifo_watermark = ST_LSM6DS3_FIFO_ELEMENT_LEN_BYTE / 2;
+
+	if (fifo_watermark != cdata->fifo_watermark) {
+		err = cdata->tf->read(cdata, ST_LSM6DS3_FIFO_THR_H_ADDR, 1, &reg_value, true);
+		if (err < 0)
+			return err;
+
+		fifo_watermark = (fifo_watermark & ST_LSM6DS3_FIFO_THR_MASK) |
+					((reg_value & ~ST_LSM6DS3_FIFO_THR_MASK) << 8);
+
+		err = cdata->tf->write(cdata, ST_LSM6DS3_FIFO_THR_L_ADDR, 2,
+						(u8 *)&fifo_watermark, true);
+		if (err < 0)
+			return err;
+
+		cdata->fifo_watermark = fifo_watermark;
+	}
+
+	return 0;
+}
+
+int st_lsm6ds3_set_fifo_mode(struct lsm6ds3_data *cdata, enum fifo_mode fm)
+{
+	int err;
+	u8 reg_value;
+	struct timespec ts;
+
+	switch (fm) {
+	case BYPASS:
+		reg_value = ST_LSM6DS3_FIFO_MODE_BYPASS;
+		break;
+	case CONTINUOS:
+		reg_value = ST_LSM6DS3_FIFO_MODE_CONTINUOS | ST_LSM6DS3_FIFO_ODR_MAX;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	err = cdata->tf->write(cdata, ST_LSM6DS3_FIFO_MODE_ADDR, 1, &reg_value, true);
+	if (err < 0)
+		return err;
+
+	if (fm != BYPASS) {
+		cdata->slower_counter = 0;
+		get_monotonic_boottime(&ts);
+		cdata->fifo_enable_timestamp = timespec_to_ns(&ts);
+		cdata->fifo_output[ST_MASK_ID_GYRO].timestamp = 0;
+		cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp = 0;
+		cdata->fifo_output[ST_MASK_ID_EXT0].timestamp = 0;
+	}
+
+	cdata->fifo_status = fm;
+
+	return 0;
+}
+EXPORT_SYMBOL(st_lsm6ds3_set_fifo_mode);
+
+static int lsm6ds3_write_decimators(struct lsm6ds3_data *cdata,
+							u8 decimators[3])
+{
+	int i;
+	u8 value[3], decimators_reg[2];
+
+	for (i = 0; i < 3; i++) {
+		switch (decimators[i]) {
+		case 0:
+		case 1:
+		case 2:
+		case 3:
+		case 4:
+			value[i] = decimators[i];
+			break;
+		case 8:
+			value[i] = 0x05;
+			break;
+		case 16:
+			value[i] = 0x06;
+			break;
+		case 32:
+			value[i] = 0x07;
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+
+	decimators_reg[0] = value[0] | (value[1] << 3);
+	decimators_reg[1] = value[2];
+
+	return cdata->tf->write(cdata, ST_LSM6DS3_FIFO_DECIMATOR_ADDR,
+			ARRAY_SIZE(decimators_reg), decimators_reg, true);
+}
+
+static bool lsm6ds3_calculate_fifo_decimators(struct lsm6ds3_data *cdata,
+				u8 decimators[3], u8 samples_in_pattern[3],
+				unsigned int new_v_odr[ST_INDIO_DEV_NUM + 1],
+				unsigned int new_hw_odr[ST_INDIO_DEV_NUM + 1],
+				int64_t new_deltatime[ST_INDIO_DEV_NUM + 1],
+				short new_fifo_decimator[ST_INDIO_DEV_NUM + 1])
+{
+	unsigned int trigger_odr;
+	u8 min_decimator, max_decimator = 0;
+	u8 accel_decimator = 0, gyro_decimator = 0, ext_decimator = 0;
+
+	trigger_odr = new_hw_odr[ST_MASK_ID_ACCEL];
+	if (trigger_odr < new_hw_odr[ST_MASK_ID_GYRO])
+		trigger_odr = new_hw_odr[ST_MASK_ID_GYRO];
+
+	if ((cdata->sensors_use_fifo & BIT(ST_MASK_ID_ACCEL)) &&
+			(new_v_odr[ST_MASK_ID_ACCEL] != 0) && cdata->accel_on)
+		accel_decimator = trigger_odr / new_v_odr[ST_MASK_ID_ACCEL];
+
+	if ((cdata->sensors_use_fifo & BIT(ST_MASK_ID_GYRO)) &&
+				(new_v_odr[ST_MASK_ID_GYRO] != 0) &&
+					(new_hw_odr[ST_MASK_ID_GYRO] > 0))
+		gyro_decimator = trigger_odr / new_v_odr[ST_MASK_ID_GYRO];
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+	if ((cdata->sensors_use_fifo & BIT(ST_MASK_ID_EXT0)) &&
+			(new_v_odr[ST_MASK_ID_EXT0] != 0) && cdata->magn_on)
+		ext_decimator = trigger_odr / new_v_odr[ST_MASK_ID_EXT0];
+
+	new_fifo_decimator[ST_MASK_ID_EXT0] = 1;
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+
+	new_fifo_decimator[ST_MASK_ID_ACCEL] = 1;
+	new_fifo_decimator[ST_MASK_ID_GYRO] = 1;
+
+	if ((accel_decimator != 0) || (gyro_decimator != 0) || (ext_decimator != 0)) {
+		min_decimator = MIN_BNZ(MIN_BNZ(accel_decimator, gyro_decimator), ext_decimator);
+		max_decimator = MAX(MAX(accel_decimator, gyro_decimator), ext_decimator);
+		if (min_decimator != 1) {
+			if ((accel_decimator / min_decimator) == 1) {
+				accel_decimator = 1;
+				new_fifo_decimator[ST_MASK_ID_ACCEL] = min_decimator;
+			} else if ((gyro_decimator / min_decimator) == 1) {
+				gyro_decimator = 1;
+				new_fifo_decimator[ST_MASK_ID_GYRO] = min_decimator;
+			} else if ((ext_decimator / min_decimator) == 1) {
+				ext_decimator = 1;
+				new_fifo_decimator[ST_MASK_ID_EXT0] = min_decimator;
+			}
+			min_decimator = 1;
+		}
+		if ((accel_decimator > 4) && (accel_decimator < 8)) {
+			new_fifo_decimator[ST_MASK_ID_ACCEL] = accel_decimator - 3;
+			accel_decimator = 4;
+		} else if ((accel_decimator > 8) && (accel_decimator < 16)) {
+			new_fifo_decimator[ST_MASK_ID_ACCEL] = accel_decimator - 7;
+			accel_decimator = 8;
+		}
+		if ((gyro_decimator > 4) && (gyro_decimator < 8)) {
+			new_fifo_decimator[ST_MASK_ID_GYRO] = gyro_decimator - 3;
+			gyro_decimator = 4;
+		} else if ((gyro_decimator > 8) && (gyro_decimator < 16)) {
+			new_fifo_decimator[ST_MASK_ID_GYRO] = gyro_decimator - 7;
+			gyro_decimator = 8;
+		}
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+		if ((ext_decimator > 4) && (ext_decimator < 8)) {
+			new_fifo_decimator[ST_MASK_ID_EXT0] = ext_decimator - 3;
+			ext_decimator = 4;
+		} else if ((ext_decimator > 8) && (ext_decimator < 16)) {
+			new_fifo_decimator[ST_MASK_ID_EXT0] = ext_decimator - 7;
+			ext_decimator = 8;
+		}
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+		max_decimator = MAX(MAX(accel_decimator, gyro_decimator), ext_decimator);
+	}
+
+	decimators[0] = accel_decimator;
+	if (accel_decimator > 0) {
+		new_deltatime[ST_MASK_ID_ACCEL] = accel_decimator *
+						(1000000000U / trigger_odr);
+		samples_in_pattern[0] = max_decimator / accel_decimator;
+	} else
+		samples_in_pattern[0] = 0;
+
+	decimators[1] = gyro_decimator;
+	if (gyro_decimator > 0) {
+		new_deltatime[ST_MASK_ID_GYRO] = gyro_decimator *
+						(1000000000U / trigger_odr);
+		samples_in_pattern[1] = max_decimator / gyro_decimator;
+	} else
+		samples_in_pattern[1] = 0;
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+	decimators[2] = ext_decimator;
+	if (ext_decimator > 0) {
+		new_deltatime[ST_MASK_ID_EXT0] = ext_decimator *
+						(1000000000U / trigger_odr);
+		samples_in_pattern[2] = max_decimator / ext_decimator;
+	} else
+		samples_in_pattern[2] = 0;
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+	if ((accel_decimator == cdata->hwfifo_decimator[ST_MASK_ID_ACCEL]) &&
+			(ext_decimator == cdata->hwfifo_decimator[ST_MASK_ID_EXT0]) &&
+			(gyro_decimator == cdata->hwfifo_decimator[ST_MASK_ID_GYRO])) {
+#else /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+	if ((accel_decimator == cdata->hwfifo_decimator[ST_MASK_ID_ACCEL]) &&
+			(gyro_decimator == cdata->hwfifo_decimator[ST_MASK_ID_GYRO])) {
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+		return false;
+	}
+
+	return true;
+}
+
+int st_lsm6ds3_set_drdy_irq(struct lsm6ds3_sensor_data *sdata, bool state)
+{
+	int err;
+	u16 *irq_mask = NULL;
+	u8 reg_addr, mask = 0, value;
+	u16 tmp_irq_enable_fifo_mask, tmp_irq_enable_accel_ext_mask;
+
+	if (state)
+		value = ST_LSM6DS3_EN_BIT;
+	else
+		value = ST_LSM6DS3_DIS_BIT;
+
+	tmp_irq_enable_fifo_mask =
+			sdata->cdata->irq_enable_fifo_mask & ~sdata->sindex;
+	tmp_irq_enable_accel_ext_mask =
+			sdata->cdata->irq_enable_accel_ext_mask & ~sdata->sindex;
+
+	switch (sdata->sindex) {
+	case ST_MASK_ID_ACCEL:
+		reg_addr = ST_LSM6DS3_INT1_ADDR;
+
+		if (sdata->cdata->hwfifo_enabled[ST_MASK_ID_ACCEL]) {
+			if (tmp_irq_enable_fifo_mask == 0)
+				mask = ST_LSM6DS3_FIFO_THR_IRQ_MASK;
+
+			irq_mask = &sdata->cdata->irq_enable_fifo_mask;
+		} else {
+			if (tmp_irq_enable_accel_ext_mask == 0)
+				mask = ST_LSM6DS3_ACCEL_DRDY_IRQ_MASK;
+
+			irq_mask = &sdata->cdata->irq_enable_accel_ext_mask;
+		}
+
+		break;
+	case ST_MASK_ID_GYRO:
+		reg_addr = ST_LSM6DS3_INT1_ADDR;
+
+		if (sdata->cdata->hwfifo_enabled[ST_MASK_ID_GYRO]) {
+			if (tmp_irq_enable_fifo_mask == 0)
+				mask = ST_LSM6DS3_FIFO_THR_IRQ_MASK;
+
+			irq_mask = &sdata->cdata->irq_enable_fifo_mask;
+		} else
+			mask = ST_LSM6DS3_GYRO_DRDY_IRQ_MASK;
+
+		break;
+	case ST_MASK_ID_SIGN_MOTION:
+		if (sdata->cdata->sensors_enabled &
+						BIT(ST_MASK_ID_STEP_DETECTOR))
+			return 0;
+
+		reg_addr = ST_LSM6DS3_INT1_ADDR;
+		mask = ST_LSM6DS3_STEP_DETECTOR_DRDY_IRQ_MASK;
+		break;
+	case ST_MASK_ID_STEP_COUNTER:
+		reg_addr = ST_LSM6DS3_INT2_ADDR;
+		mask = ST_LSM6DS3_STEP_COUNTER_DRDY_IRQ_MASK;
+		break;
+	case ST_MASK_ID_STEP_DETECTOR:
+		if (sdata->cdata->sensors_enabled & BIT(ST_MASK_ID_SIGN_MOTION))
+			return 0;
+
+		reg_addr = ST_LSM6DS3_INT1_ADDR;
+		mask = ST_LSM6DS3_STEP_DETECTOR_DRDY_IRQ_MASK;
+		break;
+	case ST_MASK_ID_TILT:
+		reg_addr = ST_LSM6DS3_MD1_ADDR;
+		mask = ST_LSM6DS3_TILT_DRDY_IRQ_MASK;
+		break;
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+	case ST_MASK_ID_EXT0:
+		reg_addr = ST_LSM6DS3_INT1_ADDR;
+
+		if (sdata->cdata->hwfifo_enabled[ST_MASK_ID_EXT0]) {
+			if (tmp_irq_enable_fifo_mask == 0)
+				mask = ST_LSM6DS3_FIFO_THR_IRQ_MASK;
+
+			irq_mask = &sdata->cdata->irq_enable_fifo_mask;
+		} else {
+			if (tmp_irq_enable_accel_ext_mask == 0)
+				mask = ST_LSM6DS3_ACCEL_DRDY_IRQ_MASK;
+
+			irq_mask = &sdata->cdata->irq_enable_accel_ext_mask;
+		}
+
+		break;
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+	default:
+		return -EINVAL;
+	}
+
+	if (mask > 0) {
+		err =  st_lsm6ds3_write_data_with_mask(sdata->cdata,
+						reg_addr, mask, value, true);
+		if (err < 0)
+			return err;
+	}
+
+	if (irq_mask != NULL) {
+		if (state)
+			*irq_mask |= BIT(sdata->sindex);
+		else
+			*irq_mask &= ~BIT(sdata->sindex);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(st_lsm6ds3_set_drdy_irq);
+
+static int st_lsm6ds3_set_odr(struct lsm6ds3_sensor_data *sdata,
+						unsigned int odr, bool force)
+{
+	u8 reg_value;
+	int err, i = 0, n;
+	int64_t temp_last_timestamp[3] = { 0 };
+	bool scan_odr = true, fifo_conf_changed;
+	unsigned int temp_v_odr[ST_INDIO_DEV_NUM + 1];
+	unsigned int temp_hw_odr[ST_INDIO_DEV_NUM + 1];
+	int64_t new_deltatime[ST_INDIO_DEV_NUM + 1] = { 0 };
+	short new_fifo_decimator[ST_INDIO_DEV_NUM + 1] = { 0 };
+	u8 fifo_decimator[3] = { 0 }, samples_in_pattern[3] = { 0 };
+	u8 temp_num_samples[3] = { 0 }, temp_old_decimator[3] = { 1 };
+
+	if (odr == 0) {
+		if (force)
+			scan_odr = false;
+		else
+			return -EINVAL;
+	}
+
+	if (scan_odr) {
+		for (i = 0; i < ST_LSM6DS3_ODR_LIST_NUM; i++) {
+			if (st_lsm6ds3_odr_table.odr_avl[i].hz == odr)
+				break;
+		}
+		if (i == ST_LSM6DS3_ODR_LIST_NUM)
+			return -EINVAL;
+
+		if (!force) {
+			if ((sdata->cdata->sensors_enabled & BIT(sdata->sindex)) == 0) {
+				sdata->cdata->v_odr[sdata->sindex] = st_lsm6ds3_odr_table.odr_avl[i].hz;
+				return 0;
+			}
+		}
+
+		if (sdata->cdata->hw_odr[sdata->sindex] == st_lsm6ds3_odr_table.odr_avl[i].hz)
+			reg_value = 0xff;
+		else
+			reg_value = st_lsm6ds3_odr_table.odr_avl[i].value;
+	} else
+		reg_value = ST_LSM6DS3_ODR_POWER_OFF_VAL;
+
+	if (sdata->cdata->sensors_use_fifo > 0) {
+		/* someone is using fifo */
+		temp_v_odr[ST_MASK_ID_ACCEL] = sdata->cdata->v_odr[ST_MASK_ID_ACCEL];
+		temp_v_odr[ST_MASK_ID_GYRO] = sdata->cdata->v_odr[ST_MASK_ID_GYRO];
+
+		if (sdata->sindex == ST_MASK_ID_ACCEL) {
+			if (force)
+				temp_v_odr[ST_MASK_ID_ACCEL] = sdata->cdata->accel_odr_dependency[0];
+
+			temp_hw_odr[ST_MASK_ID_ACCEL] = odr;
+			temp_hw_odr[ST_MASK_ID_GYRO] = sdata->cdata->hw_odr[ST_MASK_ID_GYRO];
+		} else {
+			if (!force)
+				temp_v_odr[ST_MASK_ID_GYRO] = odr;
+
+			temp_hw_odr[ST_MASK_ID_GYRO] = odr;
+			temp_hw_odr[ST_MASK_ID_ACCEL] = sdata->cdata->hw_odr[ST_MASK_ID_ACCEL];
+		}
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+		temp_v_odr[ST_MASK_ID_EXT0] = sdata->cdata->v_odr[ST_MASK_ID_EXT0];
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+
+		fifo_conf_changed = lsm6ds3_calculate_fifo_decimators(sdata->cdata,
+				fifo_decimator, samples_in_pattern, temp_v_odr,
+				temp_hw_odr, new_deltatime, new_fifo_decimator);
+		if (fifo_conf_changed) {
+			/* FIFO configuration changed, needs to write new decimators */
+			disable_irq(sdata->cdata->irq);
+
+			if (sdata->cdata->fifo_status != BYPASS) {
+				st_lsm6ds3_read_fifo(sdata->cdata, true);
+
+				temp_num_samples[0] = sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].sip;
+				temp_num_samples[1] = sdata->cdata->fifo_output[ST_MASK_ID_GYRO].sip;
+				temp_last_timestamp[0] = sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp_p;
+				temp_last_timestamp[1] = sdata->cdata->fifo_output[ST_MASK_ID_GYRO].timestamp_p;
+				temp_old_decimator[0] = sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].decimator;
+				temp_old_decimator[1] = sdata->cdata->fifo_output[ST_MASK_ID_GYRO].decimator;
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+				temp_num_samples[2] = sdata->cdata->fifo_output[ST_MASK_ID_EXT0].sip;
+				temp_last_timestamp[2] = sdata->cdata->fifo_output[ST_MASK_ID_EXT0].timestamp_p;
+				temp_old_decimator[2] = sdata->cdata->fifo_output[ST_MASK_ID_EXT0].decimator;
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+
+				err = st_lsm6ds3_set_fifo_mode(sdata->cdata, BYPASS);
+				if (err < 0)
+					goto reenable_fifo_irq;
+			} else {
+				temp_num_samples[0] = 0;
+				temp_num_samples[1] = 0;
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+				temp_num_samples[2] = 0;
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+			}
+
+			err = lsm6ds3_write_decimators(sdata->cdata, fifo_decimator);
+			if (err < 0)
+				goto reenable_fifo_irq;
+
+			if (reg_value != 0xff) {
+				err = st_lsm6ds3_write_data_with_mask(sdata->cdata,
+						st_lsm6ds3_odr_table.addr[sdata->sindex],
+						st_lsm6ds3_odr_table.mask[sdata->sindex],
+						reg_value, true);
+				if (err < 0)
+					goto reenable_fifo_irq;
+
+				if (sdata->sindex == ST_MASK_ID_ACCEL) {
+					switch (temp_hw_odr[ST_MASK_ID_ACCEL]) {
+					case 13:
+					case 26:
+					case 52:
+						if (temp_num_samples[0] == 0)
+							sdata->cdata->samples_to_discard[ST_MASK_ID_ACCEL] = ST_LSM6DS3_ACCEL_STD_52HZ;
+						else
+							sdata->cdata->samples_to_discard_2[ST_MASK_ID_ACCEL] = ST_LSM6DS3_ACCEL_STD_52HZ;
+						break;
+					case 104:
+						if (temp_num_samples[0] == 0)
+							sdata->cdata->samples_to_discard[ST_MASK_ID_ACCEL] = ST_LSM6DS3_ACCEL_STD_104HZ;
+						else
+							sdata->cdata->samples_to_discard_2[ST_MASK_ID_ACCEL] = ST_LSM6DS3_ACCEL_STD_104HZ;
+						break;
+					default:
+						if (temp_num_samples[0] == 0)
+							sdata->cdata->samples_to_discard[ST_MASK_ID_ACCEL] = ST_LSM6DS3_ACCEL_STD_208HZ;
+						else
+							sdata->cdata->samples_to_discard_2[ST_MASK_ID_ACCEL] = ST_LSM6DS3_ACCEL_STD_208HZ;
+						break;
+					}
+				}
+
+				switch (temp_hw_odr[ST_MASK_ID_GYRO]) {
+				case 13:
+					if (temp_num_samples[1] == 0)
+						sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_STD_13HZ;
+					else
+						sdata->cdata->samples_to_discard_2[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_STD_13HZ;
+					break;
+				case 26:
+				case 52:
+					if (temp_num_samples[1] == 0)
+						sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_STD_52HZ;
+					else
+						sdata->cdata->samples_to_discard_2[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_STD_52HZ;
+					break;
+				case 104:
+					if (temp_num_samples[1] == 0)
+						sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_STD_104HZ;
+					else
+						sdata->cdata->samples_to_discard_2[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_STD_104HZ;
+					break;
+				default:
+					if (temp_num_samples[1] == 0)
+						sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_STD_208HZ;
+					else
+						sdata->cdata->samples_to_discard_2[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_STD_208HZ;
+					break;
+				}
+			}
+
+			sdata->cdata->hwfifo_decimator[ST_MASK_ID_ACCEL] = fifo_decimator[0];
+			sdata->cdata->hwfifo_decimator[ST_MASK_ID_GYRO] = fifo_decimator[1];
+
+			sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].decimator = new_fifo_decimator[ST_MASK_ID_ACCEL];
+			sdata->cdata->fifo_output[ST_MASK_ID_GYRO].decimator = new_fifo_decimator[ST_MASK_ID_GYRO];
+
+			sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].num_samples = new_fifo_decimator[ST_MASK_ID_ACCEL] - 1;
+			sdata->cdata->fifo_output[ST_MASK_ID_GYRO].num_samples = new_fifo_decimator[ST_MASK_ID_GYRO] - 1;
+
+			sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].sip = samples_in_pattern[0];
+			sdata->cdata->fifo_output[ST_MASK_ID_GYRO].sip = samples_in_pattern[1];
+
+			sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime_default = new_deltatime[ST_MASK_ID_ACCEL];
+			sdata->cdata->fifo_output[ST_MASK_ID_GYRO].deltatime_default = new_deltatime[ST_MASK_ID_GYRO];
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+			sdata->cdata->hwfifo_decimator[ST_MASK_ID_EXT0] = fifo_decimator[2];
+			sdata->cdata->fifo_output[ST_MASK_ID_EXT0].decimator = new_fifo_decimator[ST_MASK_ID_EXT0];
+			sdata->cdata->fifo_output[ST_MASK_ID_EXT0].num_samples = new_fifo_decimator[ST_MASK_ID_EXT0] - 1;
+			sdata->cdata->fifo_output[ST_MASK_ID_EXT0].sip = samples_in_pattern[2];
+			sdata->cdata->fifo_output[ST_MASK_ID_EXT0].deltatime_default = new_deltatime[ST_MASK_ID_EXT0];
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+
+			err = lsm6ds3_set_watermark(sdata->cdata);
+			if (err < 0)
+				goto reenable_fifo_irq;
+
+			if ((samples_in_pattern[0] > 0) || (samples_in_pattern[1] > 0) || (samples_in_pattern[2] > 0)) {
+				err = st_lsm6ds3_set_fifo_mode(sdata->cdata, CONTINUOS);
+				if (err < 0)
+					goto reenable_fifo_irq;
+
+				if (((temp_num_samples[0] > 0) && (samples_in_pattern[0] > 0)) && (sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].initialized)) {
+					unsigned int n_gen;
+					int64_t temp_deltatime = 0;
+
+					if (sdata->cdata->fifo_enable_timestamp > temp_last_timestamp[0]) {
+						n_gen = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[0],
+							sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime * temp_old_decimator[0]);
+
+						if (n_gen > 0)
+							temp_deltatime = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[0], n_gen);
+
+						for (n = 0; n < n_gen; n++) {
+							temp_last_timestamp[0] += temp_deltatime;
+							err = st_lsm6ds3_push_data_with_timestamp(sdata->cdata, ST_MASK_ID_ACCEL,
+								sdata->cdata->accel_last_push, temp_last_timestamp[0]);
+							if (err < 0)
+								break;
+
+							sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp_p = temp_last_timestamp[0];
+						}
+					}
+				} else
+					sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime = new_deltatime[ST_MASK_ID_ACCEL];
+
+				if (((temp_num_samples[1] > 0) && (samples_in_pattern[1] > 0)) && (sdata->cdata->fifo_output[ST_MASK_ID_GYRO].initialized)) {
+					unsigned int n_gen;
+					int64_t temp_deltatime = 0;
+
+					if (sdata->cdata->fifo_enable_timestamp > temp_last_timestamp[1]) {
+						n_gen = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[1],
+							sdata->cdata->fifo_output[ST_MASK_ID_GYRO].deltatime * temp_old_decimator[1]);
+
+						if (n_gen > 0)
+							temp_deltatime = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[1], n_gen);
+
+						for (n = 0; n < n_gen; n++) {
+							temp_last_timestamp[1] += temp_deltatime;
+							err = st_lsm6ds3_push_data_with_timestamp(sdata->cdata, ST_MASK_ID_GYRO,
+								sdata->cdata->gyro_last_push, temp_last_timestamp[1]);
+							if (err < 0)
+								break;
+
+							sdata->cdata->fifo_output[ST_MASK_ID_GYRO].timestamp_p = temp_last_timestamp[1];
+						}
+					}
+				} else
+					sdata->cdata->fifo_output[ST_MASK_ID_GYRO].deltatime = new_deltatime[ST_MASK_ID_GYRO];
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+				if (((temp_num_samples[2] > 0) && (samples_in_pattern[2] > 0)) && (sdata->cdata->fifo_output[ST_MASK_ID_EXT0].initialized)) {
+					unsigned int n_gen;
+					int64_t temp_deltatime = 0;
+
+					if (sdata->cdata->fifo_enable_timestamp > temp_last_timestamp[2]) {
+						n_gen = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[2],
+							sdata->cdata->fifo_output[ST_MASK_ID_EXT0].deltatime * temp_old_decimator[2]);
+
+						if (n_gen > 0)
+							temp_deltatime = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[2], n_gen);
+
+						for (n = 0; n < n_gen; n++) {
+							temp_last_timestamp[2] += temp_deltatime;
+							err = st_lsm6ds3_push_data_with_timestamp(sdata->cdata, ST_MASK_ID_EXT0,
+								sdata->cdata->ext0_last_push, temp_last_timestamp[2]);
+							if (err < 0)
+								break;
+
+							sdata->cdata->fifo_output[ST_MASK_ID_EXT0].timestamp_p = temp_last_timestamp[2];
+						}
+					}
+				} else
+					sdata->cdata->fifo_output[ST_MASK_ID_EXT0].deltatime = new_deltatime[ST_MASK_ID_EXT0];
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+			}
+
+			enable_irq(sdata->cdata->irq);
+		} else {
+			/* FIFO configuration not changed */
+
+			if (reg_value == 0xff) {
+				if (temp_v_odr[sdata->sindex] != 0)
+					sdata->cdata->v_odr[sdata->sindex] = temp_v_odr[sdata->sindex];
+
+				sdata->cdata->hw_odr[sdata->sindex] = temp_hw_odr[sdata->sindex];
+				return 0;
+			}
+
+			disable_irq(sdata->cdata->irq);
+
+			if (sdata->cdata->fifo_status != BYPASS) {
+				st_lsm6ds3_read_fifo(sdata->cdata, true);
+
+				temp_num_samples[0] = sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].sip;
+				temp_num_samples[1] = sdata->cdata->fifo_output[ST_MASK_ID_GYRO].sip;
+				temp_last_timestamp[0] = sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp_p;
+				temp_last_timestamp[1] = sdata->cdata->fifo_output[ST_MASK_ID_GYRO].timestamp_p;
+				temp_old_decimator[0] = sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].decimator;
+				temp_old_decimator[1] = sdata->cdata->fifo_output[ST_MASK_ID_GYRO].decimator;
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+				temp_num_samples[2] = sdata->cdata->fifo_output[ST_MASK_ID_EXT0].sip;
+				temp_last_timestamp[2] = sdata->cdata->fifo_output[ST_MASK_ID_EXT0].timestamp_p;
+				temp_old_decimator[2] = sdata->cdata->fifo_output[ST_MASK_ID_EXT0].decimator;
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+
+				err = st_lsm6ds3_set_fifo_mode(sdata->cdata, BYPASS);
+				if (err < 0)
+					goto reenable_fifo_irq;
+			} else {
+				temp_num_samples[0] = 0;
+				temp_num_samples[1] = 0;
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+				temp_num_samples[2] = 0;
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+			}
+
+			err = st_lsm6ds3_write_data_with_mask(sdata->cdata,
+					st_lsm6ds3_odr_table.addr[sdata->sindex],
+					st_lsm6ds3_odr_table.mask[sdata->sindex],
+					reg_value, true);
+			if (err < 0)
+				goto reenable_fifo_irq;
+
+			if (sdata->sindex == ST_MASK_ID_ACCEL) {
+				switch (temp_hw_odr[ST_MASK_ID_ACCEL]) {
+				case 13:
+				case 26:
+				case 52:
+					if (temp_num_samples[0] == 0)
+						sdata->cdata->samples_to_discard[ST_MASK_ID_ACCEL] = ST_LSM6DS3_ACCEL_STD_52HZ;
+					else
+						sdata->cdata->samples_to_discard_2[ST_MASK_ID_ACCEL] = ST_LSM6DS3_ACCEL_STD_52HZ;
+					break;
+				case 104:
+					if (temp_num_samples[0] == 0)
+						sdata->cdata->samples_to_discard[ST_MASK_ID_ACCEL] = ST_LSM6DS3_ACCEL_STD_104HZ;
+					else
+						sdata->cdata->samples_to_discard_2[ST_MASK_ID_ACCEL] = ST_LSM6DS3_ACCEL_STD_104HZ;
+					break;
+				default:
+					if (temp_num_samples[0] == 0)
+						sdata->cdata->samples_to_discard[ST_MASK_ID_ACCEL] = ST_LSM6DS3_ACCEL_STD_208HZ;
+					else
+						sdata->cdata->samples_to_discard_2[ST_MASK_ID_ACCEL] = ST_LSM6DS3_ACCEL_STD_208HZ;
+					break;
+				}
+			}
+
+			switch (temp_hw_odr[ST_MASK_ID_GYRO]) {
+			case 13:
+				if (temp_num_samples[1] == 0)
+					sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_STD_13HZ;
+				else
+					sdata->cdata->samples_to_discard_2[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_STD_13HZ;
+				break;
+			case 26:
+			case 52:
+				if (temp_num_samples[1] == 0)
+					sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_STD_52HZ;
+				else
+					sdata->cdata->samples_to_discard_2[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_STD_52HZ;
+				break;
+			case 104:
+				if (temp_num_samples[1] == 0)
+					sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_STD_104HZ;
+				else
+					sdata->cdata->samples_to_discard_2[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_STD_104HZ;
+				break;
+			default:
+				if (temp_num_samples[1] == 0)
+					sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_STD_208HZ;
+				else
+					sdata->cdata->samples_to_discard_2[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_STD_208HZ;
+				break;
+			}
+
+			if ((sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].sip > 0) ||
+					(sdata->cdata->fifo_output[ST_MASK_ID_GYRO].sip > 0) ||
+						(sdata->cdata->fifo_output[ST_MASK_ID_EXT0].sip > 0)) {
+				err = st_lsm6ds3_set_fifo_mode(sdata->cdata, CONTINUOS);
+				if (err < 0)
+					goto reenable_fifo_irq;
+
+				if (((temp_num_samples[0] > 0) && (sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].sip > 0)) && (sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].initialized)) {
+					unsigned int n_gen;
+					int64_t temp_deltatime = 0;
+
+					if (sdata->cdata->fifo_enable_timestamp > temp_last_timestamp[0]) {
+						n_gen = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[0],
+							sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime * temp_old_decimator[0]);
+
+						if (n_gen > 0)
+							temp_deltatime = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[0], n_gen);
+
+						for (n = 0; n < n_gen; n++) {
+							temp_last_timestamp[0] += temp_deltatime;
+							err = st_lsm6ds3_push_data_with_timestamp(sdata->cdata, ST_MASK_ID_ACCEL,
+								sdata->cdata->accel_last_push, temp_last_timestamp[0]);
+							if (err < 0)
+								break;
+
+							sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].timestamp_p = temp_last_timestamp[0];
+						}
+					}
+				} else
+					sdata->cdata->fifo_output[ST_MASK_ID_ACCEL].deltatime = new_deltatime[ST_MASK_ID_ACCEL];
+
+				if (((temp_num_samples[1] > 0) && (sdata->cdata->fifo_output[ST_MASK_ID_GYRO].sip > 0)) && (sdata->cdata->fifo_output[ST_MASK_ID_GYRO].initialized)) {
+					unsigned int n_gen;
+					int64_t temp_deltatime = 0;
+
+					if (sdata->cdata->fifo_enable_timestamp > temp_last_timestamp[1]) {
+						n_gen = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[1],
+							sdata->cdata->fifo_output[ST_MASK_ID_GYRO].deltatime * temp_old_decimator[1]);
+
+						if (n_gen > 0)
+							temp_deltatime = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[1], n_gen);
+
+						for (n = 0; n < n_gen; n++) {
+							temp_last_timestamp[1] += temp_deltatime;
+							err = st_lsm6ds3_push_data_with_timestamp(sdata->cdata, ST_MASK_ID_GYRO,
+								sdata->cdata->gyro_last_push, temp_last_timestamp[1]);
+							if (err < 0)
+								break;
+
+							sdata->cdata->fifo_output[ST_MASK_ID_GYRO].timestamp_p = temp_last_timestamp[1];
+						}
+					}
+				} else
+					sdata->cdata->fifo_output[ST_MASK_ID_GYRO].deltatime = new_deltatime[ST_MASK_ID_GYRO];
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+				if (((temp_num_samples[2] > 0) && (sdata->cdata->fifo_output[ST_MASK_ID_EXT0].sip > 0)) && (sdata->cdata->fifo_output[ST_MASK_ID_EXT0].initialized)) {
+					unsigned int n_gen;
+					int64_t temp_deltatime = 0;
+
+					if (sdata->cdata->fifo_enable_timestamp > temp_last_timestamp[2]) {
+						n_gen = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[2],
+							sdata->cdata->fifo_output[ST_MASK_ID_EXT0].deltatime * temp_old_decimator[2]);
+
+						if (n_gen > 0)
+							temp_deltatime = div64_s64(sdata->cdata->fifo_enable_timestamp - temp_last_timestamp[2], n_gen);
+
+						for (n = 0; n < n_gen; n++) {
+							temp_last_timestamp[2] += temp_deltatime;
+							err = st_lsm6ds3_push_data_with_timestamp(sdata->cdata, ST_MASK_ID_EXT0,
+								sdata->cdata->ext0_last_push, temp_last_timestamp[2]);
+							if (err < 0)
+								break;
+
+							sdata->cdata->fifo_output[ST_MASK_ID_EXT0].timestamp_p = temp_last_timestamp[2];
+						}
+					}
+				} else
+					sdata->cdata->fifo_output[ST_MASK_ID_EXT0].deltatime = new_deltatime[ST_MASK_ID_EXT0];
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+			}
+
+			enable_irq(sdata->cdata->irq);
+		}
+
+		if (temp_v_odr[sdata->sindex] != 0)
+			sdata->cdata->v_odr[sdata->sindex] = temp_v_odr[sdata->sindex];
+
+		sdata->cdata->hw_odr[sdata->sindex] = temp_hw_odr[sdata->sindex];
+	} else {
+		/* no one is using FIFO */
+
+		disable_irq(sdata->cdata->irq);
+
+		if ((odr != 0) && (sdata->cdata->hw_odr[sdata->sindex] == st_lsm6ds3_odr_table.odr_avl[i].hz)) {
+			if (sdata->sindex == ST_MASK_ID_ACCEL) {
+				sdata->cdata->nofifo_decimation[ST_MASK_ID_ACCEL].decimator =
+					sdata->cdata->hw_odr[ST_MASK_ID_ACCEL] / sdata->cdata->v_odr[ST_MASK_ID_ACCEL];
+				sdata->cdata->nofifo_decimation[ST_MASK_ID_ACCEL].num_samples =
+					sdata->cdata->nofifo_decimation[ST_MASK_ID_ACCEL].decimator - 1;
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+				sdata->cdata->nofifo_decimation[ST_MASK_ID_EXT0].decimator =
+					sdata->cdata->hw_odr[ST_MASK_ID_ACCEL] / sdata->cdata->v_odr[ST_MASK_ID_EXT0];
+				sdata->cdata->nofifo_decimation[ST_MASK_ID_EXT0].num_samples =
+					sdata->cdata->nofifo_decimation[ST_MASK_ID_EXT0].decimator - 1;
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+			}
+
+			enable_irq(sdata->cdata->irq);
+
+			return 0;
+		}
+
+		err = st_lsm6ds3_write_data_with_mask(sdata->cdata,
+				st_lsm6ds3_odr_table.addr[sdata->sindex],
+				st_lsm6ds3_odr_table.mask[sdata->sindex],
+				reg_value, true);
+		if (err < 0) {
+			enable_irq(sdata->cdata->irq);
+			return err;
+		}
+
+		if (!force)
+			sdata->cdata->v_odr[sdata->sindex] = st_lsm6ds3_odr_table.odr_avl[i].hz;
+
+		if (odr == 0)
+			sdata->cdata->hw_odr[sdata->sindex] = 0;
+		else
+			sdata->cdata->hw_odr[sdata->sindex] = st_lsm6ds3_odr_table.odr_avl[i].hz;
+
+		if (sdata->sindex == ST_MASK_ID_ACCEL) {
+			switch (sdata->cdata->hw_odr[sdata->sindex]) {
+			case 13:
+			case 26:
+			case 52:
+				sdata->cdata->samples_to_discard[ST_MASK_ID_ACCEL] = ST_LSM6DS3_ACCEL_STD_52HZ;
+				break;
+			case 104:
+				sdata->cdata->samples_to_discard[ST_MASK_ID_ACCEL] = ST_LSM6DS3_ACCEL_STD_104HZ;
+				break;
+			default:
+				sdata->cdata->samples_to_discard[ST_MASK_ID_ACCEL] = ST_LSM6DS3_ACCEL_STD_208HZ;
+				break;
+			}
+		}
+
+		switch (sdata->cdata->hw_odr[ST_MASK_ID_GYRO]) {
+		case 13:
+			sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_STD_13HZ;
+			break;
+		case 26:
+		case 52:
+			sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_STD_52HZ;
+			break;
+		case 104:
+			sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_STD_104HZ;
+			break;
+		default:
+			sdata->cdata->samples_to_discard[ST_MASK_ID_GYRO] = ST_LSM6DS3_GYRO_STD_208HZ;
+			break;
+		}
+
+		if (sdata->sindex == ST_MASK_ID_ACCEL) {
+			if (sdata->cdata->hw_odr[sdata->sindex] > 0) {
+				sdata->cdata->nofifo_decimation[ST_MASK_ID_ACCEL].decimator =
+					sdata->cdata->hw_odr[ST_MASK_ID_ACCEL] / sdata->cdata->v_odr[ST_MASK_ID_ACCEL];
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+				sdata->cdata->nofifo_decimation[ST_MASK_ID_EXT0].decimator =
+					sdata->cdata->hw_odr[ST_MASK_ID_ACCEL] / sdata->cdata->v_odr[ST_MASK_ID_EXT0];
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+			} else {
+				sdata->cdata->nofifo_decimation[ST_MASK_ID_ACCEL].decimator = 1;
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+				sdata->cdata->nofifo_decimation[ST_MASK_ID_EXT0].decimator = 1;
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+			}
+
+			sdata->cdata->nofifo_decimation[ST_MASK_ID_ACCEL].num_samples =
+				sdata->cdata->nofifo_decimation[ST_MASK_ID_ACCEL].decimator - 1;
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+			sdata->cdata->nofifo_decimation[ST_MASK_ID_EXT0].num_samples =
+				sdata->cdata->nofifo_decimation[ST_MASK_ID_EXT0].decimator - 1;
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+		}
+
+		enable_irq(sdata->cdata->irq);
+	}
+
+	sdata->cdata->trigger_odr = sdata->cdata->hw_odr[0] > sdata->cdata->hw_odr[1] ? sdata->cdata->hw_odr[0] : sdata->cdata->hw_odr[1];
+
+	return 0;
+
+reenable_fifo_irq:
+	enable_irq(sdata->cdata->irq);
+	return err;
+}
+
+/*
+ * Enable / disable accelerometer
+ */
+static int lsm6ds3_enable_accel(struct lsm6ds3_data *cdata, enum st_mask_id id, int min_odr)
+{
+	int odr;
+	struct lsm6ds3_sensor_data *sdata_accel = iio_priv(cdata->indio_dev[ST_MASK_ID_ACCEL]);
+
+	switch (id) {
+	case ST_MASK_ID_ACCEL:
+		cdata->accel_odr_dependency[0] = min_odr;
+		if (min_odr > 0)
+			cdata->accel_on = true;
+		else
+			cdata->accel_on = false;
+
+		break;
+	case ST_MASK_ID_SENSOR_HUB:
+		cdata->accel_odr_dependency[1] = min_odr;
+		if (min_odr > 0)
+			cdata->magn_on = true;
+		else
+			cdata->magn_on = false;
+
+		break;
+	case ST_MASK_ID_DIGITAL_FUNC:
+		cdata->accel_odr_dependency[2] = min_odr;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (cdata->accel_odr_dependency[0] > cdata->accel_odr_dependency[1])
+		odr = cdata->accel_odr_dependency[0];
+	else
+		odr = cdata->accel_odr_dependency[1];
+
+	if (cdata->accel_odr_dependency[2] > odr)
+		odr = cdata->accel_odr_dependency[2];
+
+#ifdef CONFIG_ST_LSM6DS3_XL_DATA_INJECTION
+	if (cdata->injection_mode)
+		return 0;
+#endif /* CONFIG_ST_LSM6DS3_XL_DATA_INJECTION */
+
+	return st_lsm6ds3_set_odr(sdata_accel, odr, true);
+}
+
+/*
+ * Enable / disable digital func
+ */
+static int lsm6ds3_enable_digital_func(struct lsm6ds3_data *cdata,
+					bool enable, enum st_mask_id id)
+{
+	int err;
+
+	if (enable) {
+		if (cdata->enable_digfunc_mask == 0) {
+			err = lsm6ds3_enable_accel(cdata,
+						ST_MASK_ID_DIGITAL_FUNC, 26);
+			if (err < 0)
+				return err;
+
+			err = st_lsm6ds3_write_data_with_mask(cdata,
+						ST_LSM6DS3_FUNC_EN_ADDR,
+						ST_LSM6DS3_FUNC_EN_MASK,
+						ST_LSM6DS3_EN_BIT, true);
+			if (err < 0)
+				return err;
+		}
+		cdata->enable_digfunc_mask |= BIT(id);
+	} else {
+		if ((cdata->enable_digfunc_mask & ~BIT(id)) == 0) {
+			err = st_lsm6ds3_write_data_with_mask(cdata,
+						ST_LSM6DS3_FUNC_EN_ADDR,
+						ST_LSM6DS3_FUNC_EN_MASK,
+						ST_LSM6DS3_DIS_BIT, true);
+			if (err < 0)
+				return err;
+
+			err = lsm6ds3_enable_accel(cdata,
+						ST_MASK_ID_DIGITAL_FUNC, 0);
+			if (err < 0)
+				return err;
+		}
+		cdata->enable_digfunc_mask &= ~BIT(id);
+
+	}
+
+	return 0;
+}
+
+/*
+ * Enable / disable HW pedometer
+ */
+static int lsm6ds3_enable_pedometer(struct lsm6ds3_data *cdata,
+					bool enable, enum st_mask_id id)
+{
+	int err;
+
+	if (enable) {
+		if (cdata->enable_pedometer_mask == 0) {
+			err =  st_lsm6ds3_write_data_with_mask(cdata,
+						ST_LSM6DS3_PEDOMETER_EN_ADDR,
+						ST_LSM6DS3_PEDOMETER_EN_MASK,
+						ST_LSM6DS3_EN_BIT, true);
+			if (err < 0)
+				return err;
+
+			err = lsm6ds3_enable_digital_func(cdata,
+						true, ST_MASK_ID_HW_PEDOMETER);
+			if (err < 0)
+				return err;
+		} else {
+			if (id == ST_MASK_ID_SIGN_MOTION) {
+				err = st_lsm6ds3_write_data_with_mask(cdata,
+						ST_LSM6DS3_PEDOMETER_EN_ADDR,
+						ST_LSM6DS3_PEDOMETER_EN_MASK,
+						ST_LSM6DS3_DIS_BIT, true);
+				if (err < 0)
+					return err;
+
+				err = st_lsm6ds3_write_data_with_mask(cdata,
+						ST_LSM6DS3_PEDOMETER_EN_ADDR,
+						ST_LSM6DS3_PEDOMETER_EN_MASK,
+						ST_LSM6DS3_EN_BIT, true);
+				if (err < 0)
+					return err;
+			}
+		}
+		cdata->enable_pedometer_mask |= BIT(id);
+	} else {
+		if ((cdata->enable_pedometer_mask & ~BIT(id)) == 0) {
+			err =  st_lsm6ds3_write_data_with_mask(cdata,
+						ST_LSM6DS3_PEDOMETER_EN_ADDR,
+						ST_LSM6DS3_PEDOMETER_EN_MASK,
+						ST_LSM6DS3_DIS_BIT, true);
+			if (err < 0)
+				return err;
+
+			err = lsm6ds3_enable_digital_func(cdata,
+						false, ST_MASK_ID_HW_PEDOMETER);
+			if (err < 0)
+				return err;
+		}
+		cdata->enable_pedometer_mask &= ~BIT(id);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+int st_lsm6ds3_enable_sensor_hub(struct lsm6ds3_data *cdata,
+					bool enable, enum st_mask_id id)
+{
+	int err;
+
+	if (enable) {
+		if (cdata->enable_sensorhub_mask == 0) {
+			err = lsm6ds3_enable_digital_func(cdata,
+						true, ST_MASK_ID_SENSOR_HUB);
+			if (err < 0)
+				return err;
+
+			err = lsm6ds3_enable_accel(cdata, ST_MASK_ID_SENSOR_HUB,
+						cdata->v_odr[ST_MASK_ID_EXT0]);
+			if (err < 0)
+				return err;
+
+			err = st_lsm6ds3_write_data_with_mask(cdata,
+						ST_LSM6DS3_SENSORHUB_ADDR,
+						ST_LSM6DS3_SENSORHUB_MASK,
+						ST_LSM6DS3_EN_BIT, true);
+			if (err < 0)
+				return err;
+		} else
+			err = lsm6ds3_enable_accel(cdata, ST_MASK_ID_SENSOR_HUB,
+						cdata->v_odr[ST_MASK_ID_EXT0]);
+
+		cdata->enable_sensorhub_mask |= BIT(id);
+	} else {
+		if ((cdata->enable_sensorhub_mask & ~BIT(id)) == 0) {
+			err = st_lsm6ds3_write_data_with_mask(cdata,
+						ST_LSM6DS3_SENSORHUB_ADDR,
+						ST_LSM6DS3_SENSORHUB_MASK,
+						ST_LSM6DS3_DIS_BIT, true);
+			if (err < 0)
+				return err;
+
+			err = lsm6ds3_enable_accel(cdata,
+						ST_MASK_ID_SENSOR_HUB, 0);
+			if (err < 0)
+				return err;
+
+			err = lsm6ds3_enable_digital_func(cdata,
+						false, ST_MASK_ID_SENSOR_HUB);
+			if (err < 0)
+				return err;
+		} else
+			err = lsm6ds3_enable_accel(cdata, ST_MASK_ID_SENSOR_HUB,
+						cdata->v_odr[ST_MASK_ID_EXT0]);
+
+		cdata->enable_sensorhub_mask &= ~BIT(id);
+	}
+
+	return err < 0 ? err : 0;
+}
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+
+int st_lsm6ds3_set_enable(struct lsm6ds3_sensor_data *sdata, bool enable, bool buffer)
+{
+	int err;
+	u8 reg_value;
+
+	switch (sdata->sindex) {
+	case ST_MASK_ID_ACCEL:
+		err = lsm6ds3_enable_accel(sdata->cdata, ST_MASK_ID_ACCEL,
+			enable ? sdata->cdata->v_odr[ST_MASK_ID_ACCEL] : 0);
+		if (err < 0)
+			return 0;
+
+		break;
+	case ST_MASK_ID_GYRO:
+		err = st_lsm6ds3_set_odr(sdata, enable ?
+			sdata->cdata->v_odr[ST_MASK_ID_GYRO] : 0, true);
+		if (err < 0)
+			return err;
+
+		break;
+	case ST_MASK_ID_SIGN_MOTION:
+		if (enable)
+			reg_value = ST_LSM6DS3_EN_BIT;
+		else
+			reg_value = ST_LSM6DS3_DIS_BIT;
+
+		err = st_lsm6ds3_write_data_with_mask(sdata->cdata,
+					ST_LSM6DS3_SIGN_MOTION_EN_ADDR,
+					ST_LSM6DS3_SIGN_MOTION_EN_MASK,
+					reg_value, true);
+		if (err < 0)
+			return err;
+
+		err = lsm6ds3_enable_pedometer(sdata->cdata,
+						enable, ST_MASK_ID_SIGN_MOTION);
+		if (err < 0)
+			return err;
+
+		break;
+	case ST_MASK_ID_STEP_COUNTER:
+		if (enable)
+			reg_value = ST_LSM6DS3_EN_BIT;
+		else
+			reg_value = ST_LSM6DS3_DIS_BIT;
+
+		err = st_lsm6ds3_write_data_with_mask(sdata->cdata,
+					ST_LSM6DS3_TIMER_EN_ADDR,
+					ST_LSM6DS3_TIMER_EN_MASK,
+					reg_value, true);
+		if (err < 0)
+			return err;
+
+		err = lsm6ds3_enable_pedometer(sdata->cdata,
+					enable, ST_MASK_ID_STEP_COUNTER);
+		if (err < 0)
+			return err;
+
+		break;
+	case ST_MASK_ID_STEP_DETECTOR:
+		err = lsm6ds3_enable_pedometer(sdata->cdata,
+					enable, ST_MASK_ID_STEP_DETECTOR);
+		if (err < 0)
+			return err;
+
+		break;
+	case ST_MASK_ID_TILT:
+		if (enable)
+			reg_value = ST_LSM6DS3_EN_BIT;
+		else
+			reg_value = ST_LSM6DS3_DIS_BIT;
+
+		err = st_lsm6ds3_write_data_with_mask(sdata->cdata,
+					ST_LSM6DS3_TILT_EN_ADDR,
+					ST_LSM6DS3_TILT_EN_MASK,
+					reg_value, true);
+		if (err < 0)
+			return err;
+
+		err = lsm6ds3_enable_digital_func(sdata->cdata,
+						enable, ST_MASK_ID_TILT);
+		if (err < 0)
+			return err;
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (buffer) {
+		err = st_lsm6ds3_set_drdy_irq(sdata, enable);
+		if (err < 0)
+			return err;
+
+		if (enable)
+			sdata->cdata->sensors_enabled |= BIT(sdata->sindex);
+		else
+			sdata->cdata->sensors_enabled &= ~BIT(sdata->sindex);
+	}
+
+	return 0;
+}
+
+static int st_lsm6ds3_set_fs(struct lsm6ds3_sensor_data *sdata,
+							unsigned int gain)
+{
+	int err, i;
+	u8 pedometer_reg_value;
+
+	for (i = 0; i < ST_LSM6DS3_FS_LIST_NUM; i++) {
+		if (st_lsm6ds3_fs_table[sdata->sindex].fs_avl[i].gain == gain)
+			break;
+	}
+	if (i == ST_LSM6DS3_FS_LIST_NUM)
+		return -EINVAL;
+
+	err = st_lsm6ds3_write_data_with_mask(sdata->cdata,
+			st_lsm6ds3_fs_table[sdata->sindex].addr,
+			st_lsm6ds3_fs_table[sdata->sindex].mask,
+			st_lsm6ds3_fs_table[sdata->sindex].fs_avl[i].value,
+			true);
+	if (err < 0)
+		return err;
+
+	sdata->c_gain[0] = gain;
+
+	if (sdata->sindex == ST_MASK_ID_ACCEL) {
+		if (i == 0)
+			pedometer_reg_value = ST_LSM6DS3_STEP_COUNTER_THS_2G_VALUE;
+		else
+			pedometer_reg_value = ST_LSM6DS3_STEP_COUNTER_THS_4G_VALUE;
+
+		st_lsm6ds3_write_embedded_registers(sdata->cdata,
+					ST_LSM6DS3_STEP_COUNTER_THS_ADDR,
+					&pedometer_reg_value, 1);
+	}
+
+	return 0;
+}
+
+static int st_lsm6ds3_read_raw(struct iio_dev *indio_dev,
+			struct iio_chan_spec const *ch, int *val,
+							int *val2, long mask)
+{
+	int err;
+	u8 outdata[ST_LSM6DS3_BYTE_FOR_CHANNEL];
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		mutex_lock(&indio_dev->mlock);
+
+		if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+			mutex_unlock(&indio_dev->mlock);
+			return -EBUSY;
+		}
+
+		mutex_lock(&sdata->cdata->odr_lock);
+
+		err = st_lsm6ds3_set_enable(sdata, true, false);
+		if (err < 0) {
+			mutex_unlock(&sdata->cdata->odr_lock);
+			mutex_unlock(&indio_dev->mlock);
+			return err;
+		}
+
+		if (sdata->sindex == ST_MASK_ID_ACCEL)
+			msleep(40);
+
+		if (sdata->sindex == ST_MASK_ID_GYRO)
+			msleep(120);
+
+		err = sdata->cdata->tf->read(sdata->cdata, ch->address,
+				ST_LSM6DS3_BYTE_FOR_CHANNEL, outdata, true);
+		if (err < 0) {
+			st_lsm6ds3_set_enable(sdata, false, false);
+			mutex_unlock(&sdata->cdata->odr_lock);
+			mutex_unlock(&indio_dev->mlock);
+			return err;
+		}
+
+		*val = (s16)get_unaligned_le16(outdata);
+		*val = *val >> ch->scan_type.shift;
+
+		st_lsm6ds3_set_enable(sdata, false, false);
+
+		mutex_unlock(&sdata->cdata->odr_lock);
+		mutex_unlock(&indio_dev->mlock);
+
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		*val = 0;
+		*val2 = sdata->c_gain[0];
+		return IIO_VAL_INT_PLUS_MICRO;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int st_lsm6ds3_write_raw(struct iio_dev *indio_dev,
+		struct iio_chan_spec const *chan, int val, int val2, long mask)
+{
+	int err;
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		mutex_lock(&indio_dev->mlock);
+
+		if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+			mutex_unlock(&indio_dev->mlock);
+			return -EBUSY;
+		}
+
+		err = st_lsm6ds3_set_fs(sdata, val2);
+		mutex_unlock(&indio_dev->mlock);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return err < 0 ? err : 0;
+}
+
+static int st_lsm6ds3_reset_steps(struct lsm6ds3_data *cdata)
+{
+	int err;
+	u8 reg_value = 0x00;
+
+	err = cdata->tf->read(cdata,
+			ST_LSM6DS3_STEP_COUNTER_RES_ADDR, 1, &reg_value, true);
+	if (err < 0)
+		return err;
+
+	if (reg_value & ST_LSM6DS3_FUNC_EN_MASK)
+		reg_value = ST_LSM6DS3_STEP_COUNTER_RES_FUNC_EN;
+	else
+		reg_value = ST_LSM6DS3_DIS_BIT;
+
+	err = st_lsm6ds3_write_data_with_mask(cdata,
+				ST_LSM6DS3_STEP_COUNTER_RES_ADDR,
+				ST_LSM6DS3_STEP_COUNTER_RES_MASK,
+				ST_LSM6DS3_STEP_COUNTER_RES_ALL_EN, true);
+	if (err < 0)
+		return err;
+
+	err = st_lsm6ds3_write_data_with_mask(cdata,
+				ST_LSM6DS3_STEP_COUNTER_RES_ADDR,
+				ST_LSM6DS3_STEP_COUNTER_RES_MASK,
+				reg_value, true);
+	if (err < 0)
+		return err;
+
+	cdata->reset_steps = true;
+
+	return 0;
+}
+
+static int st_lsm6ds3_init_sensor(struct lsm6ds3_data *cdata)
+{
+	int err;
+	u8 default_reg_value = ST_LSM6DS3_RESET_MASK;
+
+	err = cdata->tf->write(cdata, ST_LSM6DS3_RESET_ADDR, 1,
+					&default_reg_value, true);
+	if (err < 0)
+		return err;
+
+	msleep(200);
+
+	/* Latch interrupts */
+	err = st_lsm6ds3_write_data_with_mask(cdata, ST_LSM6DS3_LIR_ADDR,
+				ST_LSM6DS3_LIR_MASK, ST_LSM6DS3_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	/* Enable BDU for sensors data */
+	err = st_lsm6ds3_write_data_with_mask(cdata, ST_LSM6DS3_BDU_ADDR,
+				ST_LSM6DS3_BDU_MASK, ST_LSM6DS3_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = st_lsm6ds3_write_data_with_mask(cdata,
+					ST_LSM6DS3_ROUNDING_ADDR,
+					ST_LSM6DS3_ROUNDING_MASK,
+					ST_LSM6DS3_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	/* Redirect INT2 on INT1, all interrupt will be available on INT1 */
+	err = st_lsm6ds3_write_data_with_mask(cdata,
+					ST_LSM6DS3_INT2_ON_INT1_ADDR,
+					ST_LSM6DS3_INT2_ON_INT1_MASK,
+					ST_LSM6DS3_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = st_lsm6ds3_reset_steps(cdata);
+	if (err < 0)
+		return err;
+
+	default_reg_value = 0x00;
+
+	err = st_lsm6ds3_write_embedded_registers(cdata,
+					ST_LSM6DS3_STEP_COUNTER_DURATION_ADDR,
+					&default_reg_value, 1);
+	if (err < 0)
+		return err;
+
+	default_reg_value = ST_LSM6DS3_STEP_COUNTER_THS_2G_VALUE;
+
+	err = st_lsm6ds3_write_embedded_registers(cdata,
+					ST_LSM6DS3_STEP_COUNTER_THS_ADDR,
+					&default_reg_value, 1);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int st_lsm6ds3_set_selftest(struct lsm6ds3_sensor_data *sdata, int index)
+{
+	u8 mode, mask;
+
+	switch (sdata->sindex) {
+	case ST_MASK_ID_ACCEL:
+		mask = ST_LSM6DS3_SELFTEST_ACCEL_MASK;
+		mode = st_lsm6ds3_selftest_table[index].accel_value;
+		break;
+	case ST_MASK_ID_GYRO:
+		mask = ST_LSM6DS3_SELFTEST_GYRO_MASK;
+		mode = st_lsm6ds3_selftest_table[index].gyro_value;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return st_lsm6ds3_write_data_with_mask(sdata->cdata,
+				ST_LSM6DS3_SELFTEST_ADDR, mask, mode, true);
+}
+
+static ssize_t st_lsm6ds3_sysfs_set_max_delivery_rate(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	u8 duration;
+	int err;
+	unsigned int max_delivery_rate;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = kstrtouint(buf, 10, &max_delivery_rate);
+	if (err < 0)
+		return -EINVAL;
+
+	if (max_delivery_rate == sdata->cdata->v_odr[ST_MASK_ID_STEP_COUNTER])
+		return size;
+
+	duration = max_delivery_rate / ST_LSM6DS3_MIN_DURATION_MS;
+
+	err = st_lsm6ds3_write_embedded_registers(sdata->cdata,
+					ST_LSM6DS3_STEP_COUNTER_DURATION_ADDR,
+					&duration, 1);
+	if (err < 0)
+		return err;
+
+	sdata->cdata->v_odr[ST_MASK_ID_STEP_COUNTER] = max_delivery_rate;
+
+	return size;
+}
+
+static ssize_t st_lsm6ds3_sysfs_get_max_delivery_rate(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct lsm6ds3_sensor_data *sdata = iio_priv(dev_get_drvdata(dev));
+
+	return sprintf(buf, "%d\n",
+				sdata->cdata->v_odr[ST_MASK_ID_STEP_COUNTER]);
+}
+
+static ssize_t st_lsm6ds3_sysfs_reset_counter(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int err;
+	struct lsm6ds3_sensor_data *sdata = iio_priv(dev_get_drvdata(dev));
+
+	err = st_lsm6ds3_reset_steps(sdata->cdata);
+	if (err < 0)
+		return err;
+
+	return size;
+}
+
+static ssize_t st_lsm6ds3_sysfs_get_sampling_frequency(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct lsm6ds3_sensor_data *sdata = iio_priv(dev_get_drvdata(dev));
+
+	return sprintf(buf, "%d\n", sdata->cdata->v_odr[sdata->sindex]);
+}
+
+static ssize_t st_lsm6ds3_sysfs_set_sampling_frequency(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int err;
+	unsigned int odr;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = kstrtoint(buf, 10, &odr);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&indio_dev->mlock);
+
+	mutex_lock(&sdata->cdata->odr_lock);
+#ifdef CONFIG_ST_LSM6DS3_XL_DATA_INJECTION
+	if (!((sdata->sindex & ST_MASK_ID_ACCEL) &&
+					sdata->cdata->injection_mode)) {
+		if (sdata->cdata->v_odr[sdata->sindex] != odr)
+			err = st_lsm6ds3_set_odr(sdata, odr, false);
+	}
+#else /* CONFIG_ST_LSM6DS3_XL_DATA_INJECTION */
+	if (sdata->cdata->v_odr[sdata->sindex] != odr) {
+		if ((sdata->sindex == ST_MASK_ID_ACCEL) && (sdata->cdata->sensors_enabled & BIT(ST_MASK_ID_ACCEL)))
+			err = lsm6ds3_enable_accel(sdata->cdata, ST_MASK_ID_ACCEL, odr);
+		else
+			err = st_lsm6ds3_set_odr(sdata, odr, false);
+	}
+#endif /* CONFIG_ST_LSM6DS3_XL_DATA_INJECTION */
+	mutex_unlock(&sdata->cdata->odr_lock);
+
+	mutex_unlock(&indio_dev->mlock);
+
+	return err < 0 ? err : size;
+}
+
+static ssize_t st_lsm6ds3_sysfs_sampling_frequency_avail(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int i, len = 0;
+
+	for (i = 0; i < ST_LSM6DS3_ODR_LIST_NUM; i++) {
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+					st_lsm6ds3_odr_table.odr_avl[i].hz);
+	}
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static ssize_t st_lsm6ds3_sysfs_scale_avail(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int i, len = 0;
+	struct lsm6ds3_sensor_data *sdata = iio_priv(dev_get_drvdata(dev));
+
+	for (i = 0; i < ST_LSM6DS3_FS_LIST_NUM; i++) {
+		len += scnprintf(buf + len, PAGE_SIZE - len, "0.%06u ",
+			st_lsm6ds3_fs_table[sdata->sindex].fs_avl[i].gain);
+	}
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static ssize_t st_lsm6ds3_sysfs_get_selftest_available(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s, %s\n",
+				st_lsm6ds3_selftest_table[1].string_mode,
+				st_lsm6ds3_selftest_table[2].string_mode);
+}
+
+static ssize_t st_lsm6ds3_sysfs_get_selftest_status(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int8_t result;
+	char *message;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	mutex_lock(&sdata->cdata->odr_lock);
+
+	switch (sdata->sindex) {
+	case ST_MASK_ID_ACCEL:
+		result = sdata->cdata->accel_selftest_status;
+		break;
+	case ST_MASK_ID_GYRO:
+		result = sdata->cdata->gyro_selftest_status;
+		break;
+	default:
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return -EINVAL;
+	}
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+
+	if (result == 0)
+		message = ST_LSM6DS3_SELFTEST_NA_MS;
+	else if (result < 0)
+		message = ST_LSM6DS3_SELFTEST_FAIL_MS;
+	else if (result > 0)
+		message = ST_LSM6DS3_SELFTEST_PASS_MS;
+
+	return sprintf(buf, "%s\n", message);
+}
+
+static ssize_t st_lsm6ds3_sysfs_start_selftest(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int err, i, n;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+	u8 reg_status, reg_addr, temp_reg_status, outdata[6];
+	int x = 0, y = 0, z = 0, x_selftest = 0, y_selftest = 0, z_selftest = 0;
+
+	mutex_lock(&sdata->cdata->odr_lock);
+
+	switch (sdata->sindex) {
+	case ST_MASK_ID_ACCEL:
+		sdata->cdata->accel_selftest_status = 0;
+		break;
+	case ST_MASK_ID_GYRO:
+		sdata->cdata->gyro_selftest_status = 0;
+		break;
+	default:
+		mutex_unlock(&sdata->cdata->odr_lock);
+		mutex_unlock(&indio_dev->mlock);
+		return -EINVAL;
+	}
+
+	if (sdata->cdata->sensors_enabled > 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return -EBUSY;
+	}
+
+	for (n = 1; n < ARRAY_SIZE(st_lsm6ds3_selftest_table); n++) {
+		if (strncmp(buf, st_lsm6ds3_selftest_table[n].string_mode,
+								size - 2) == 0)
+			break;
+	}
+	if (n == ARRAY_SIZE(st_lsm6ds3_selftest_table)) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return -EINVAL;
+	}
+
+	switch (sdata->sindex) {
+	case ST_MASK_ID_ACCEL:
+		reg_addr = ST_LSM6DS3_SELFTEST_ACCEL_ADDR;
+		temp_reg_status = ST_LSM6DS3_SELFTEST_ACCEL_REG_VALUE;
+		break;
+	case ST_MASK_ID_GYRO:
+		reg_addr = ST_LSM6DS3_SELFTEST_GYRO_ADDR;
+		temp_reg_status = ST_LSM6DS3_SELFTEST_GYRO_REG_VALUE;
+		break;
+	default:
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return -EINVAL;
+	}
+
+	err = sdata->cdata->tf->read(sdata->cdata,
+					reg_addr, 1, &reg_status, true);
+	if (err < 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return err;
+	}
+
+	err = sdata->cdata->tf->write(sdata->cdata,
+					reg_addr, 1, &temp_reg_status, false);
+	if (err < 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return err;
+	}
+
+	/* get data with selftest disabled */
+	msleep(100);
+
+	for (i = 0; i < 20; i++) {
+		err = sdata->cdata->tf->read(sdata->cdata,
+					sdata->data_out_reg, 6, outdata, true);
+		if (err < 0) {
+			i--;
+			continue;
+		}
+
+		x += ((s16)*(u16 *)&outdata[0]) / 20;
+		y += ((s16)*(u16 *)&outdata[2]) / 20;
+		z += ((s16)*(u16 *)&outdata[4]) / 20;
+
+		mdelay(10);
+	}
+
+	err = st_lsm6ds3_set_selftest(sdata, n);
+	if (err < 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return err;
+	}
+
+	/* get data with selftest enabled */
+	msleep(100);
+
+	for (i = 0; i < 20; i++) {
+		err = sdata->cdata->tf->read(sdata->cdata,
+					sdata->data_out_reg, 6, outdata, true);
+		if (err < 0) {
+			i--;
+			continue;
+		}
+
+		x_selftest += ((s16)*(u16 *)&outdata[0]) / 20;
+		y_selftest += ((s16)*(u16 *)&outdata[2]) / 20;
+		z_selftest += ((s16)*(u16 *)&outdata[4]) / 20;
+
+		mdelay(10);
+	}
+
+	err = sdata->cdata->tf->write(sdata->cdata,
+					reg_addr, 1, &reg_status, false);
+	if (err < 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return err;
+	}
+
+	err = st_lsm6ds3_set_selftest(sdata, 0);
+	if (err < 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return err;
+	}
+
+	switch (sdata->sindex) {
+	case ST_MASK_ID_ACCEL:
+		if ((abs(x_selftest - x) < ST_LSM6DS3_SELFTEST_ACCEL_MIN) ||
+				(abs(x_selftest - x) > ST_LSM6DS3_SELFTEST_ACCEL_MAX)) {
+			sdata->cdata->accel_selftest_status = -1;
+			goto selftest_failure;
+		}
+
+		if ((abs(y_selftest - y) < ST_LSM6DS3_SELFTEST_ACCEL_MIN) ||
+				(abs(y_selftest - y) > ST_LSM6DS3_SELFTEST_ACCEL_MAX)) {
+			sdata->cdata->accel_selftest_status = -1;
+			goto selftest_failure;
+		}
+
+		if ((abs(z_selftest - z) < ST_LSM6DS3_SELFTEST_ACCEL_MIN) ||
+				(abs(z_selftest - z) > ST_LSM6DS3_SELFTEST_ACCEL_MAX)) {
+			sdata->cdata->accel_selftest_status = -1;
+			goto selftest_failure;
+		}
+
+		sdata->cdata->accel_selftest_status = 1;
+		break;
+	case ST_MASK_ID_GYRO:
+		if ((abs(x_selftest - x) < ST_LSM6DS3_SELFTEST_GYRO_MIN) ||
+				(abs(x_selftest - x) > ST_LSM6DS3_SELFTEST_GYRO_MAX)) {
+			sdata->cdata->gyro_selftest_status = -1;
+			goto selftest_failure;
+		}
+
+		if ((abs(y_selftest - y) < ST_LSM6DS3_SELFTEST_GYRO_MIN) ||
+				(abs(y_selftest - y) > ST_LSM6DS3_SELFTEST_GYRO_MAX)) {
+			sdata->cdata->gyro_selftest_status = -1;
+			goto selftest_failure;
+		}
+
+		if ((abs(z_selftest - z) < ST_LSM6DS3_SELFTEST_GYRO_MIN) ||
+				(abs(z_selftest - z) > ST_LSM6DS3_SELFTEST_GYRO_MAX)) {
+			sdata->cdata->gyro_selftest_status = -1;
+			goto selftest_failure;
+		}
+
+		sdata->cdata->gyro_selftest_status = 1;
+		break;
+	default:
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return -EINVAL;
+	}
+
+selftest_failure:
+	mutex_unlock(&sdata->cdata->odr_lock);
+
+	return size;
+}
+
+ssize_t st_lsm6ds3_sysfs_flush_fifo(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	u64 sensor_last_timestamp, event_type = 0;
+	int stype = 0;
+	u64 timestamp_flush = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+
+	if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+		mutex_lock(&sdata->cdata->odr_lock);
+		disable_irq(sdata->cdata->irq);
+	} else {
+		mutex_unlock(&indio_dev->mlock);
+		return -EINVAL;
+	}
+
+	sensor_last_timestamp =
+			sdata->cdata->fifo_output[sdata->sindex].timestamp_p;
+
+	st_lsm6ds3_read_fifo(sdata->cdata, true);
+
+	if (sensor_last_timestamp ==
+			sdata->cdata->fifo_output[sdata->sindex].timestamp_p)
+		event_type = IIO_EV_DIR_FIFO_EMPTY;
+	else
+		event_type = IIO_EV_DIR_FIFO_DATA;
+
+	timestamp_flush = sdata->cdata->fifo_output[sdata->sindex].timestamp_p;
+
+	enable_irq(sdata->cdata->irq);
+
+	switch (sdata->sindex) {
+	case ST_MASK_ID_ACCEL:
+		stype = IIO_ACCEL;
+		break;
+
+	case ST_MASK_ID_GYRO:
+		stype = IIO_ANGL_VEL;
+		break;
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+	case ST_MASK_ID_EXT0:
+		stype = IIO_MAGN;
+		break;
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+
+	}
+
+	iio_push_event(indio_dev, IIO_UNMOD_EVENT_CODE(stype,
+				-1, IIO_EV_TYPE_FIFO_FLUSH, event_type),
+				timestamp_flush);
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+	mutex_unlock(&indio_dev->mlock);
+
+	return size;
+}
+
+ssize_t st_lsm6ds3_sysfs_get_hwfifo_enabled(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	return sprintf(buf, "%d\n",
+				sdata->cdata->hwfifo_enabled[sdata->sindex]);
+}
+
+ssize_t st_lsm6ds3_sysfs_set_hwfifo_enabled(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int err;
+	bool enable = false;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	if (sdata->cdata->spi_connection) {
+		dev_info(sdata->cdata->dev,
+				"FIFO not supported with SPI connection.\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&indio_dev->mlock);
+	if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+		err = -EBUSY;
+		goto set_hwfifo_enabled_unlock_mutex;
+	}
+
+	err = strtobool(buf, &enable);
+	if (err < 0)
+		goto set_hwfifo_enabled_unlock_mutex;
+
+	mutex_lock(&sdata->cdata->odr_lock);
+
+	sdata->cdata->hwfifo_enabled[sdata->sindex] = enable;
+
+	if (enable)
+		sdata->cdata->sensors_use_fifo |= BIT(sdata->sindex);
+	else
+		sdata->cdata->sensors_use_fifo &= ~BIT(sdata->sindex);
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+	mutex_unlock(&indio_dev->mlock);
+
+	return size;
+
+set_hwfifo_enabled_unlock_mutex:
+	mutex_unlock(&indio_dev->mlock);
+	return err;
+}
+
+ssize_t st_lsm6ds3_sysfs_get_hwfifo_watermark(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	return sprintf(buf, "%d\n",
+				sdata->cdata->hwfifo_watermark[sdata->sindex]);
+}
+
+ssize_t st_lsm6ds3_sysfs_set_hwfifo_watermark(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int err = 0, watermark = 0, old_watermark;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = kstrtoint(buf, 10, &watermark);
+	if (err < 0)
+		return err;
+
+	if ((watermark < 1) || (watermark > ST_LSM6DS3_MAX_FIFO_LENGHT))
+		return -EINVAL;
+
+	mutex_lock(&sdata->cdata->odr_lock);
+
+	if ((sdata->cdata->sensors_enabled & BIT(sdata->sindex)) &&
+				(sdata->cdata->sensors_use_fifo & BIT(sdata->sindex))) {
+		disable_irq(sdata->cdata->irq);
+
+		if (sdata->cdata->fifo_status != BYPASS)
+			st_lsm6ds3_read_fifo(sdata->cdata, true);
+
+		old_watermark = sdata->cdata->hwfifo_watermark[sdata->sindex];
+		sdata->cdata->hwfifo_watermark[sdata->sindex] = watermark;
+
+		err = lsm6ds3_set_watermark(sdata->cdata);
+		if (err < 0)
+			sdata->cdata->hwfifo_watermark[sdata->sindex] = old_watermark;
+
+		enable_irq(sdata->cdata->irq);
+	} else
+		sdata->cdata->hwfifo_watermark[sdata->sindex] = watermark;
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+
+	return err < 0 ? err : size;
+}
+
+ssize_t st_lsm6ds3_sysfs_get_hwfifo_watermark_max(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", ST_LSM6DS3_MAX_FIFO_LENGHT);
+}
+
+ssize_t st_lsm6ds3_sysfs_get_hwfifo_watermark_min(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", 1);
+}
+
+#ifdef CONFIG_ST_LSM6DS3_XL_DATA_INJECTION
+static ssize_t st_lsm6ds3_sysfs_set_injection_mode(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int err, start;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+
+	if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+		mutex_unlock(&indio_dev->mlock);
+		return -EBUSY;
+	}
+
+	err = kstrtoint(buf, 10, &start);
+	if (err < 0) {
+		mutex_unlock(&indio_dev->mlock);
+		return err;
+	}
+
+	mutex_lock(&sdata->cdata->odr_lock);
+
+	if (start == 0) {
+		hrtimer_cancel(&sdata->cdata->injection_timer);
+
+		/* End injection */
+		err = st_lsm6ds3_write_data_with_mask(sdata->cdata,
+				ST_LSM6DS3_TEST_REG_ADDR,
+				ST_LSM6DS3_START_INJECT_XL_MASK, 0, true);
+		if (err < 0) {
+			mutex_unlock(&sdata->cdata->odr_lock);
+			mutex_unlock(&indio_dev->mlock);
+			return err;
+		}
+
+			/* Force accel ODR to 26Hz if dependencies are enabled */
+		if (sdata->cdata->sensors_enabled > 0) {
+			err = st_lsm6ds3_write_data_with_mask(sdata->cdata,
+				st_lsm6ds3_odr_table.addr[sdata->sindex],
+				st_lsm6ds3_odr_table.mask[sdata->sindex],
+				st_lsm6ds3_odr_table.odr_avl[1].value, true);
+			if (err < 0) {
+				mutex_unlock(&sdata->cdata->odr_lock);
+				mutex_unlock(&indio_dev->mlock);
+				return err;
+			}
+		}
+
+		sdata->cdata->injection_mode = false;
+	} else {
+		sdata->cdata->last_injection_timestamp = 0;
+		sdata->cdata->injection_samples = 0;
+
+		/* Force accel ODR to 26Hz */
+		err = st_lsm6ds3_write_data_with_mask(sdata->cdata,
+				st_lsm6ds3_odr_table.addr[sdata->sindex],
+				st_lsm6ds3_odr_table.mask[sdata->sindex],
+				st_lsm6ds3_odr_table.odr_avl[1].value, true);
+		if (err < 0) {
+			mutex_unlock(&sdata->cdata->odr_lock);
+			mutex_unlock(&indio_dev->mlock);
+			return err;
+		}
+
+		/* Set start injection */
+		err = st_lsm6ds3_write_data_with_mask(sdata->cdata,
+				ST_LSM6DS3_TEST_REG_ADDR,
+				ST_LSM6DS3_START_INJECT_XL_MASK, 1, true);
+		if (err < 0) {
+			mutex_unlock(&sdata->cdata->odr_lock);
+			mutex_unlock(&indio_dev->mlock);
+			return err;
+		}
+
+		sdata->cdata->injection_mode = true;
+	}
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+	mutex_unlock(&indio_dev->mlock);
+
+	return size;
+}
+
+static ssize_t st_lsm6ds3_sysfs_get_injection_mode(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	return sprintf(buf, "%d\n", sdata->cdata->injection_mode);
+}
+
+static ssize_t st_lsm6ds3_sysfs_upload_xl_data(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int i;
+	u8 sample[3];
+	s64 timestamp;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+
+	if (!sdata->cdata->injection_mode) {
+		mutex_unlock(&indio_dev->mlock);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < 3; i++)
+		sample[i] = *(s16 *)(&buf[i * 2]) >> 8;
+
+	timestamp = *(s64 *)(buf + ALIGN(6, sizeof(s64)));
+
+	if (timestamp < sdata->cdata->last_injection_timestamp +
+						ST_LSM6DS3_NS_AT_25HZ) {
+		mutex_unlock(&indio_dev->mlock);
+		return size;
+	}
+
+	while (sdata->cdata->injection_samples >= 10)
+		msleep(200);
+
+	spin_lock(&sdata->cdata->injection_spinlock);
+
+	memcpy(&sdata->cdata->injection_data[
+			sdata->cdata->injection_samples * 3], sample, 3);
+	sdata->cdata->injection_samples++;
+
+	spin_unlock(&sdata->cdata->injection_spinlock);
+
+	sdata->cdata->last_injection_timestamp = timestamp;
+
+	if (sdata->cdata->injection_samples >= 8)
+		hrtimer_start(&sdata->cdata->injection_timer,
+			ktime_set(0, ST_LSM6DS3_26HZ_NS), HRTIMER_MODE_REL);
+
+	mutex_unlock(&indio_dev->mlock);
+
+	return size;
+}
+
+static void st_lsm6ds3_injection_work(struct work_struct *work)
+{
+	int i, err;
+	struct lsm6ds3_data *cdata;
+
+	cdata = container_of(work, struct lsm6ds3_data, injection_work);
+
+	if (cdata->injection_samples == 0)
+		return;
+
+	err = cdata->tf->write(cdata, ST_LSM6DS3_INJECT_XL_X_ADDR,
+					3, cdata->injection_data, false);
+	if (err < 0)
+		return;
+
+	spin_lock(&cdata->injection_spinlock);
+
+	for (i = 0; i < cdata->injection_samples - 1; i++)
+		memcpy(&cdata->injection_data[i * 3],
+				&cdata->injection_data[(i + 1) * 3], 3);
+
+	cdata->injection_samples--;
+
+	spin_unlock(&cdata->injection_spinlock);
+}
+
+static enum hrtimer_restart st_lsm6ds3_injection_timer_func(
+							struct hrtimer *timer)
+{
+	ktime_t now;
+	struct lsm6ds3_data *cdata;
+
+	cdata = container_of(timer, struct lsm6ds3_data, injection_timer);
+
+	now = hrtimer_cb_get_time(timer);
+	hrtimer_forward(timer, now, ktime_set(0, ST_LSM6DS3_26HZ_NS));
+
+	schedule_work(&cdata->injection_work);
+
+	return HRTIMER_RESTART;
+}
+
+static ssize_t st_lsm6ds3_sysfs_get_injection_sensors(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n", "lsm6ds3_accel");
+}
+#endif /* CONFIG_ST_LSM6DS3_XL_DATA_INJECTION */
+
+static ST_LSM6DS3_DEV_ATTR_SAMP_FREQ();
+static ST_LSM6DS3_DEV_ATTR_SAMP_FREQ_AVAIL();
+static ST_LSM6DS3_DEV_ATTR_SCALE_AVAIL(in_accel_scale_available);
+static ST_LSM6DS3_DEV_ATTR_SCALE_AVAIL(in_anglvel_scale_available);
+
+static ST_LSM6DS3_HWFIFO_ENABLED();
+static ST_LSM6DS3_HWFIFO_WATERMARK();
+static ST_LSM6DS3_HWFIFO_WATERMARK_MIN();
+static ST_LSM6DS3_HWFIFO_WATERMARK_MAX();
+static ST_LSM6DS3_HWFIFO_FLUSH();
+
+static IIO_DEVICE_ATTR(reset_counter, S_IWUSR,
+				NULL, st_lsm6ds3_sysfs_reset_counter, 0);
+
+static IIO_DEVICE_ATTR(max_delivery_rate, S_IWUSR | S_IRUGO,
+				st_lsm6ds3_sysfs_get_max_delivery_rate,
+				st_lsm6ds3_sysfs_set_max_delivery_rate, 0);
+
+static IIO_DEVICE_ATTR(selftest_available, S_IRUGO,
+				st_lsm6ds3_sysfs_get_selftest_available,
+				NULL, 0);
+
+static IIO_DEVICE_ATTR(selftest, S_IWUSR | S_IRUGO,
+				st_lsm6ds3_sysfs_get_selftest_status,
+				st_lsm6ds3_sysfs_start_selftest, 0);
+
+#ifdef CONFIG_ST_LSM6DS3_XL_DATA_INJECTION
+static IIO_DEVICE_ATTR(injection_mode, S_IWUSR | S_IRUGO,
+				st_lsm6ds3_sysfs_get_injection_mode,
+				st_lsm6ds3_sysfs_set_injection_mode, 0);
+
+static IIO_DEVICE_ATTR(in_accel_injection_raw, S_IWUSR, NULL,
+				st_lsm6ds3_sysfs_upload_xl_data, 0);
+
+static IIO_DEVICE_ATTR(injection_sensors, S_IRUGO,
+				st_lsm6ds3_sysfs_get_injection_sensors,
+				NULL, 0);
+#endif /* CONFIG_ST_LSM6DS3_XL_DATA_INJECTION */
+
+static struct attribute *st_lsm6ds3_accel_attributes[] = {
+	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_dev_attr_in_accel_scale_available.dev_attr.attr,
+	&iio_dev_attr_sampling_frequency.dev_attr.attr,
+	&iio_dev_attr_selftest_available.dev_attr.attr,
+	&iio_dev_attr_selftest.dev_attr.attr,
+	&iio_dev_attr_hwfifo_enabled.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_min.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_max.dev_attr.attr,
+	&iio_dev_attr_hwfifo_flush.dev_attr.attr,
+#ifdef CONFIG_ST_LSM6DS3_XL_DATA_INJECTION
+	&iio_dev_attr_injection_mode.dev_attr.attr,
+	&iio_dev_attr_in_accel_injection_raw.dev_attr.attr,
+#endif /* CONFIG_ST_LSM6DS3_XL_DATA_INJECTION */
+	NULL,
+};
+
+static const struct attribute_group st_lsm6ds3_accel_attribute_group = {
+	.attrs = st_lsm6ds3_accel_attributes,
+};
+
+static const struct iio_info st_lsm6ds3_accel_info = {
+	.driver_module = THIS_MODULE,
+	.attrs = &st_lsm6ds3_accel_attribute_group,
+	.read_raw = &st_lsm6ds3_read_raw,
+	.write_raw = &st_lsm6ds3_write_raw,
+};
+
+static struct attribute *st_lsm6ds3_gyro_attributes[] = {
+	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_scale_available.dev_attr.attr,
+	&iio_dev_attr_sampling_frequency.dev_attr.attr,
+	&iio_dev_attr_selftest_available.dev_attr.attr,
+	&iio_dev_attr_selftest.dev_attr.attr,
+	&iio_dev_attr_hwfifo_enabled.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_min.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_max.dev_attr.attr,
+	&iio_dev_attr_hwfifo_flush.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_lsm6ds3_gyro_attribute_group = {
+	.attrs = st_lsm6ds3_gyro_attributes,
+};
+
+static const struct iio_info st_lsm6ds3_gyro_info = {
+	.driver_module = THIS_MODULE,
+	.attrs = &st_lsm6ds3_gyro_attribute_group,
+	.read_raw = &st_lsm6ds3_read_raw,
+	.write_raw = &st_lsm6ds3_write_raw,
+};
+
+static struct attribute *st_lsm6ds3_sign_motion_attributes[] = {
+#ifdef CONFIG_ST_LSM6DS3_XL_DATA_INJECTION
+	&iio_dev_attr_injection_sensors.dev_attr.attr,
+#endif /* CONFIG_ST_LSM6DS3_XL_DATA_INJECTION */
+	NULL,
+};
+
+static const struct attribute_group st_lsm6ds3_sign_motion_attribute_group = {
+	.attrs = st_lsm6ds3_sign_motion_attributes,
+};
+
+static const struct iio_info st_lsm6ds3_sign_motion_info = {
+	.driver_module = THIS_MODULE,
+	.attrs = &st_lsm6ds3_sign_motion_attribute_group,
+};
+
+static struct attribute *st_lsm6ds3_step_c_attributes[] = {
+	&iio_dev_attr_reset_counter.dev_attr.attr,
+	&iio_dev_attr_max_delivery_rate.dev_attr.attr,
+#ifdef CONFIG_ST_LSM6DS3_XL_DATA_INJECTION
+	&iio_dev_attr_injection_sensors.dev_attr.attr,
+#endif /* CONFIG_ST_LSM6DS3_XL_DATA_INJECTION */
+	NULL,
+};
+
+static const struct attribute_group st_lsm6ds3_step_c_attribute_group = {
+	.attrs = st_lsm6ds3_step_c_attributes,
+};
+
+static const struct iio_info st_lsm6ds3_step_c_info = {
+	.driver_module = THIS_MODULE,
+	.attrs = &st_lsm6ds3_step_c_attribute_group,
+	.read_raw = &st_lsm6ds3_read_raw,
+};
+
+static struct attribute *st_lsm6ds3_step_d_attributes[] = {
+#ifdef CONFIG_ST_LSM6DS3_XL_DATA_INJECTION
+	&iio_dev_attr_injection_sensors.dev_attr.attr,
+#endif /* CONFIG_ST_LSM6DS3_XL_DATA_INJECTION */
+	NULL,
+};
+
+static const struct attribute_group st_lsm6ds3_step_d_attribute_group = {
+	.attrs = st_lsm6ds3_step_d_attributes,
+};
+
+static const struct iio_info st_lsm6ds3_step_d_info = {
+	.driver_module = THIS_MODULE,
+	.attrs = &st_lsm6ds3_step_d_attribute_group,
+};
+
+static struct attribute *st_lsm6ds3_tilt_attributes[] = {
+#ifdef CONFIG_ST_LSM6DS3_XL_DATA_INJECTION
+	&iio_dev_attr_injection_sensors.dev_attr.attr,
+#endif /* CONFIG_ST_LSM6DS3_XL_DATA_INJECTION */
+	NULL,
+};
+
+static const struct attribute_group st_lsm6ds3_tilt_attribute_group = {
+	.attrs = st_lsm6ds3_tilt_attributes,
+};
+
+static const struct iio_info st_lsm6ds3_tilt_info = {
+	.driver_module = THIS_MODULE,
+	.attrs = &st_lsm6ds3_tilt_attribute_group,
+};
+
+#ifdef CONFIG_IIO_TRIGGER
+static const struct iio_trigger_ops st_lsm6ds3_trigger_ops = {
+	.owner = THIS_MODULE,
+	.set_trigger_state = ST_LSM6DS3_TRIGGER_SET_STATE,
+};
+#define ST_LSM6DS3_TRIGGER_OPS (&st_lsm6ds3_trigger_ops)
+#else
+#define ST_LSM6DS3_TRIGGER_OPS NULL
+#endif
+
+int st_lsm6ds3_common_probe(struct lsm6ds3_data *cdata, int irq)
+{
+	u8 wai = 0x00;
+	int i, n, err;
+	struct lsm6ds3_sensor_data *sdata;
+
+	mutex_init(&cdata->bank_registers_lock);
+	mutex_init(&cdata->fifo_lock);
+	mutex_init(&cdata->tb.buf_lock);
+	mutex_init(&cdata->odr_lock);
+
+	cdata->fifo_watermark = 0;
+	cdata->fifo_status = BYPASS;
+	cdata->enable_digfunc_mask = 0;
+	cdata->enable_pedometer_mask = 0;
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+	cdata->enable_sensorhub_mask = 0;
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+
+	cdata->irq_enable_fifo_mask = 0;
+	cdata->irq_enable_accel_ext_mask = 0;
+
+	for (i = 0; i < ST_INDIO_DEV_NUM + 1; i++) {
+		cdata->hw_odr[i] = 0;
+		cdata->v_odr[i] = 13;
+		cdata->hwfifo_enabled[i] = false;
+		cdata->hwfifo_decimator[i] = 0;
+		cdata->hwfifo_watermark[i] = 1;
+		cdata->nofifo_decimation[i].decimator = 1;
+		cdata->nofifo_decimation[i].num_samples = 0;
+		cdata->fifo_output[i].sip = 0;
+		cdata->fifo_output[i].decimator = 1;
+		cdata->fifo_output[i].timestamp_p = 0;
+		cdata->fifo_output[i].sip = 0;
+		cdata->fifo_output[i].initialized = false;
+	}
+
+	cdata->sensors_use_fifo = 0;
+	cdata->sensors_enabled = 0;
+
+	cdata->gyro_selftest_status = 0;
+	cdata->accel_selftest_status = 0;
+
+	cdata->accel_on = false;
+	cdata->magn_on = false;
+
+	cdata->reset_steps = false;
+	cdata->sign_motion_event_ready = false;
+	cdata->num_steps = 0;
+
+	cdata->accel_odr_dependency[0] = 0;
+	cdata->accel_odr_dependency[1] = 0;
+	cdata->accel_odr_dependency[2] = 0;
+
+	cdata->trigger_odr = 0;
+
+	cdata->fifo_data = kmalloc(ST_LSM6DS3_MAX_FIFO_SIZE *
+						sizeof(u8), GFP_KERNEL);
+	if (!cdata->fifo_data)
+		return -ENOMEM;
+
+#ifdef CONFIG_ST_LSM6DS3_XL_DATA_INJECTION
+	cdata->injection_mode = false;
+	cdata->last_injection_timestamp = 0;
+
+	INIT_WORK(&cdata->injection_work, &st_lsm6ds3_injection_work);
+	hrtimer_init(&cdata->injection_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	cdata->injection_timer.function = &st_lsm6ds3_injection_timer_func;
+	spin_lock_init(&cdata->injection_spinlock);
+#endif /* CONFIG_ST_LSM6DS3_XL_DATA_INJECTION */
+
+	err = cdata->tf->read(cdata, ST_LSM6DS3_WAI_ADDRESS, 1, &wai, true);
+	if (err < 0) {
+		dev_err(cdata->dev, "failed to read Who-Am-I register.\n");
+		goto free_fifo_data;
+	}
+	if (wai != ST_LSM6DS3_WAI_EXP) {
+		dev_err(cdata->dev,
+			"Who-Am-I value not valid. Expected %x, Found %x\n",
+						ST_LSM6DS3_WAI_EXP, wai);
+		err = -ENODEV;
+		goto free_fifo_data;
+	}
+
+	if (irq > 0) {
+		cdata->irq = irq;
+		dev_info(cdata->dev, "driver use DRDY int pin 1.\n");
+	} else {
+		err = -EINVAL;
+		dev_err(cdata->dev,
+			"DRDY not available, current implementation needs irq!\n");
+		goto free_fifo_data;
+	}
+
+	for (i = 0; i < ST_INDIO_DEV_NUM; i++) {
+		cdata->indio_dev[i] = iio_device_alloc(sizeof(struct lsm6ds3_sensor_data));
+		if (!cdata->indio_dev[i]) {
+			err = -ENOMEM;
+			goto iio_device_free;
+		}
+
+		sdata = iio_priv(cdata->indio_dev[i]);
+		sdata->cdata = cdata;
+		sdata->sindex = i;
+
+		switch (i) {
+		case ST_MASK_ID_ACCEL:
+			sdata->data_out_reg = st_lsm6ds3_accel_ch[0].address;
+			cdata->v_odr[i] = st_lsm6ds3_odr_table.odr_avl[0].hz;
+			sdata->c_gain[0] = st_lsm6ds3_fs_table[i].fs_avl[0].gain;
+			sdata->cdata->samples_to_discard_2[ST_MASK_ID_ACCEL] = 0;
+			sdata->num_data_channels = 3;
+			break;
+		case ST_MASK_ID_GYRO:
+			sdata->data_out_reg = st_lsm6ds3_gyro_ch[0].address;
+			cdata->v_odr[i] = st_lsm6ds3_odr_table.odr_avl[0].hz;
+			sdata->c_gain[0] = st_lsm6ds3_fs_table[i].fs_avl[0].gain;
+			sdata->cdata->samples_to_discard_2[ST_MASK_ID_GYRO] = 0;
+			sdata->num_data_channels = 3;
+			break;
+		case ST_MASK_ID_STEP_COUNTER:
+			sdata->data_out_reg = st_lsm6ds3_step_c_ch[0].address;
+			sdata->num_data_channels = 1;
+			break;
+
+		default:
+			sdata->num_data_channels = 0;
+			break;
+		}
+
+		cdata->indio_dev[i]->modes = INDIO_DIRECT_MODE;
+	}
+
+	cdata->indio_dev[ST_MASK_ID_ACCEL]->name =
+			kasprintf(GFP_KERNEL, "%s_%s", cdata->name,
+					ST_LSM6DS3_ACCEL_SUFFIX_NAME);
+	cdata->indio_dev[ST_MASK_ID_ACCEL]->info = &st_lsm6ds3_accel_info;
+	cdata->indio_dev[ST_MASK_ID_ACCEL]->channels = st_lsm6ds3_accel_ch;
+	cdata->indio_dev[ST_MASK_ID_ACCEL]->num_channels =
+						ARRAY_SIZE(st_lsm6ds3_accel_ch);
+
+	cdata->indio_dev[ST_MASK_ID_GYRO]->name =
+			kasprintf(GFP_KERNEL, "%s_%s", cdata->name,
+					ST_LSM6DS3_GYRO_SUFFIX_NAME);
+	cdata->indio_dev[ST_MASK_ID_GYRO]->info = &st_lsm6ds3_gyro_info;
+	cdata->indio_dev[ST_MASK_ID_GYRO]->channels = st_lsm6ds3_gyro_ch;
+	cdata->indio_dev[ST_MASK_ID_GYRO]->num_channels =
+						ARRAY_SIZE(st_lsm6ds3_gyro_ch);
+
+	cdata->indio_dev[ST_MASK_ID_SIGN_MOTION]->name =
+			kasprintf(GFP_KERNEL, "%s_%s", cdata->name,
+					ST_LSM6DS3_SIGN_MOTION_SUFFIX_NAME);
+	cdata->indio_dev[ST_MASK_ID_SIGN_MOTION]->info =
+						&st_lsm6ds3_sign_motion_info;
+	cdata->indio_dev[ST_MASK_ID_SIGN_MOTION]->channels =
+						st_lsm6ds3_sign_motion_ch;
+	cdata->indio_dev[ST_MASK_ID_SIGN_MOTION]->num_channels =
+					ARRAY_SIZE(st_lsm6ds3_sign_motion_ch);
+
+	cdata->indio_dev[ST_MASK_ID_STEP_COUNTER]->name =
+			kasprintf(GFP_KERNEL, "%s_%s", cdata->name,
+					ST_LSM6DS3_STEP_COUNTER_SUFFIX_NAME);
+	cdata->indio_dev[ST_MASK_ID_STEP_COUNTER]->info =
+						&st_lsm6ds3_step_c_info;
+	cdata->indio_dev[ST_MASK_ID_STEP_COUNTER]->channels =
+						st_lsm6ds3_step_c_ch;
+	cdata->indio_dev[ST_MASK_ID_STEP_COUNTER]->num_channels =
+					ARRAY_SIZE(st_lsm6ds3_step_c_ch);
+
+	cdata->indio_dev[ST_MASK_ID_STEP_DETECTOR]->name =
+			kasprintf(GFP_KERNEL, "%s_%s", cdata->name,
+					ST_LSM6DS3_STEP_DETECTOR_SUFFIX_NAME);
+	cdata->indio_dev[ST_MASK_ID_STEP_DETECTOR]->info =
+						&st_lsm6ds3_step_d_info;
+	cdata->indio_dev[ST_MASK_ID_STEP_DETECTOR]->channels =
+						st_lsm6ds3_step_d_ch;
+	cdata->indio_dev[ST_MASK_ID_STEP_DETECTOR]->num_channels =
+					ARRAY_SIZE(st_lsm6ds3_step_d_ch);
+
+	cdata->indio_dev[ST_MASK_ID_TILT]->name =
+			kasprintf(GFP_KERNEL, "%s_%s", cdata->name,
+					ST_LSM6DS3_TILT_SUFFIX_NAME);
+	cdata->indio_dev[ST_MASK_ID_TILT]->info = &st_lsm6ds3_tilt_info;
+	cdata->indio_dev[ST_MASK_ID_TILT]->channels = st_lsm6ds3_tilt_ch;
+	cdata->indio_dev[ST_MASK_ID_TILT]->num_channels =
+					ARRAY_SIZE(st_lsm6ds3_tilt_ch);
+
+	err = st_lsm6ds3_init_sensor(cdata);
+	if (err < 0)
+		goto iio_device_free;
+
+	err = st_lsm6ds3_allocate_rings(cdata);
+	if (err < 0)
+		goto iio_device_free;
+
+	if (irq > 0) {
+		err = st_lsm6ds3_allocate_triggers(cdata,
+							ST_LSM6DS3_TRIGGER_OPS);
+		if (err < 0)
+			goto deallocate_ring;
+	}
+
+	for (n = 0; n < ST_INDIO_DEV_NUM; n++) {
+		err = iio_device_register(cdata->indio_dev[n]);
+		if (err)
+			goto iio_device_unregister_and_trigger_deallocate;
+	}
+
+	if (strcmp(cdata->name, LSM6DS33_DEV_NAME) != 0)
+		st_lsm6ds3_i2c_master_probe(cdata);
+
+	device_init_wakeup(cdata->dev, true);
+
+	return 0;
+
+iio_device_unregister_and_trigger_deallocate:
+	for (n--; n >= 0; n--)
+		iio_device_unregister(cdata->indio_dev[n]);
+
+	if (irq > 0)
+		st_lsm6ds3_deallocate_triggers(cdata);
+deallocate_ring:
+	st_lsm6ds3_deallocate_rings(cdata);
+iio_device_free:
+	for (i--; i >= 0; i--)
+		iio_device_free(cdata->indio_dev[i]);
+free_fifo_data:
+	kfree(cdata->fifo_data);
+
+	return err;
+}
+EXPORT_SYMBOL(st_lsm6ds3_common_probe);
+
+void st_lsm6ds3_common_remove(struct lsm6ds3_data *cdata, int irq)
+{
+	int i;
+
+	for (i = 0; i < ST_INDIO_DEV_NUM; i++)
+		iio_device_unregister(cdata->indio_dev[i]);
+
+	if (irq > 0)
+		st_lsm6ds3_deallocate_triggers(cdata);
+
+	st_lsm6ds3_deallocate_rings(cdata);
+
+	for (i = 0; i < ST_INDIO_DEV_NUM; i++)
+		iio_device_free(cdata->indio_dev[i]);
+
+	kfree(cdata->fifo_data);
+
+	if (strcmp(cdata->name, LSM6DS33_DEV_NAME) != 0)
+		st_lsm6ds3_i2c_master_exit(cdata);
+}
+EXPORT_SYMBOL(st_lsm6ds3_common_remove);
+
+#ifdef CONFIG_PM
+int st_lsm6ds3_common_suspend(struct lsm6ds3_data *cdata)
+{
+	int err, i;
+	u8 tmp_sensors_enabled;
+	struct lsm6ds3_sensor_data *sdata;
+
+	tmp_sensors_enabled = cdata->sensors_enabled;
+
+	for (i = 0; i < ST_INDIO_DEV_NUM; i++) {
+		if ((i == ST_MASK_ID_SIGN_MOTION) || (i == ST_MASK_ID_TILT))
+			continue;
+
+		sdata = iio_priv(cdata->indio_dev[i]);
+
+#ifdef CONFIG_ST_LSM6DS3_STEP_COUNTER_ON_DURING_SUSPEND
+		if ((BIT(i) & cdata->sensors_enabled) &&
+					(i == ST_MASK_ID_STEP_COUNTER)) {
+			err =  st_lsm6ds3_write_data_with_mask(sdata->cdata,
+					ST_LSM6DS3_INT2_ADDR,
+					ST_LSM6DS3_STEP_COUNTER_DRDY_IRQ_MASK,
+					ST_LSM6DS3_DIS_BIT, true);
+			if (err < 0)
+				return err;
+
+			continue;
+		}
+#endif /* CONFIG_ST_LSM6DS3_STEP_COUNTER_ON_DURING_SUSPEND */
+
+		err = st_lsm6ds3_set_enable(sdata, false, true);
+		if (err < 0)
+			return err;
+	}
+	cdata->sensors_enabled = tmp_sensors_enabled;
+
+	if (cdata->sensors_enabled & ST_LSM6DS3_WAKE_UP_SENSORS) {
+		if (device_may_wakeup(cdata->dev))
+			enable_irq_wake(cdata->irq);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(st_lsm6ds3_common_suspend);
+
+int st_lsm6ds3_common_resume(struct lsm6ds3_data *cdata)
+{
+	int err, i;
+	struct lsm6ds3_sensor_data *sdata;
+
+	for (i = 0; i < ST_INDIO_DEV_NUM; i++) {
+		if ((i == ST_MASK_ID_SIGN_MOTION) || (i == ST_MASK_ID_TILT))
+			continue;
+
+		sdata = iio_priv(cdata->indio_dev[i]);
+
+		if (BIT(sdata->sindex) & cdata->sensors_enabled) {
+#ifdef CONFIG_ST_LSM6DS3_STEP_COUNTER_ON_DURING_SUSPEND
+			if (i == ST_MASK_ID_STEP_COUNTER) {
+				err =  st_lsm6ds3_write_data_with_mask(sdata->cdata,
+					ST_LSM6DS3_INT2_ADDR,
+					ST_LSM6DS3_STEP_COUNTER_DRDY_IRQ_MASK,
+					ST_LSM6DS3_EN_BIT, true);
+				if (err < 0)
+					return err;
+
+				continue;
+			}
+#endif /* CONFIG_ST_LSM6DS3_STEP_COUNTER_ON_DURING_SUSPEND */
+
+			err = st_lsm6ds3_set_enable(sdata, true, true);
+			if (err < 0)
+				return err;
+		}
+	}
+
+	if (cdata->sensors_enabled & ST_LSM6DS3_WAKE_UP_SENSORS) {
+		if (device_may_wakeup(cdata->dev))
+			disable_irq_wake(cdata->irq);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(st_lsm6ds3_common_resume);
+#endif /* CONFIG_PM */
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics lsm6ds3 core driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_i2c.c b/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_i2c.c
new file mode 100755
index 0000000..ad39a19
--- /dev/null
+++ b/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_i2c.c
@@ -0,0 +1,180 @@
+/*
+ * STMicroelectronics lsm6ds3 i2c driver
+ *
+ * Copyright 2014-2016 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/of.h>
+#include <linux/iio/iio.h>
+
+#include "st_lsm6ds3.h"
+
+static int st_lsm6ds3_i2c_read(struct lsm6ds3_data *cdata,
+				u8 reg_addr, int len, u8 *data, bool b_lock)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	if (b_lock) {
+		mutex_lock(&cdata->bank_registers_lock);
+		err = i2c_transfer(client->adapter, msg, 2);
+		mutex_unlock(&cdata->bank_registers_lock);
+	} else
+		err = i2c_transfer(client->adapter, msg, 2);
+
+	return err;
+}
+
+static int st_lsm6ds3_i2c_write(struct lsm6ds3_data *cdata,
+				u8 reg_addr, int len, u8 *data, bool b_lock)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	if (b_lock) {
+		mutex_lock(&cdata->bank_registers_lock);
+		err = i2c_transfer(client->adapter, &msg, 1);
+		mutex_unlock(&cdata->bank_registers_lock);
+	} else
+		err = i2c_transfer(client->adapter, &msg, 1);
+
+	return err;
+}
+
+static const struct st_lsm6ds3_transfer_function st_lsm6ds3_tf_i2c = {
+	.write = st_lsm6ds3_i2c_write,
+	.read = st_lsm6ds3_i2c_read,
+};
+
+static int st_lsm6ds3_i2c_probe(struct i2c_client *client,
+						const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm6ds3_data *cdata;
+
+	cdata = kmalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &client->dev;
+	cdata->name = client->name;
+	i2c_set_clientdata(client, cdata);
+
+	cdata->spi_connection = false;
+	cdata->tf = &st_lsm6ds3_tf_i2c;
+
+	err = st_lsm6ds3_common_probe(cdata, client->irq);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+	return err;
+}
+
+static int st_lsm6ds3_i2c_remove(struct i2c_client *client)
+{
+	struct lsm6ds3_data *cdata = i2c_get_clientdata(client);
+
+	st_lsm6ds3_common_remove(cdata, client->irq);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int st_lsm6ds3_suspend(struct device *dev)
+{
+	struct lsm6ds3_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return st_lsm6ds3_common_suspend(cdata);
+}
+
+static int st_lsm6ds3_resume(struct device *dev)
+{
+	struct lsm6ds3_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return st_lsm6ds3_common_resume(cdata);
+}
+
+static const struct dev_pm_ops st_lsm6ds3_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(st_lsm6ds3_suspend, st_lsm6ds3_resume)
+};
+
+#define ST_LSM6DS3_PM_OPS		(&st_lsm6ds3_pm_ops)
+#else /* CONFIG_PM */
+#define ST_LSM6DS3_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id st_lsm6ds3_id_table[] = {
+	{ LSM6DS3_DEV_NAME },
+	{ LSM6DS33_DEV_NAME },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, st_lsm6ds3_id_table);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm6ds3_of_match[] = {
+	{
+		.compatible = "st,lsm6ds3",
+		.data = LSM6DS3_DEV_NAME,
+	},
+	{
+		.compatible = "st,lsm6ds33",
+		.data = LSM6DS33_DEV_NAME,
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, lsm6ds3_of_match);
+#else /* CONFIG_OF */
+#define lsm6ds3_of_match		NULL
+#endif /* CONFIG_OF */
+
+static struct i2c_driver st_lsm6ds3_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "st-lsm6ds3-i2c",
+		.pm = ST_LSM6DS3_PM_OPS,
+		.of_match_table = of_match_ptr(lsm6ds3_of_match),
+	},
+	.probe = st_lsm6ds3_i2c_probe,
+	.remove = st_lsm6ds3_i2c_remove,
+	.id_table = st_lsm6ds3_id_table,
+};
+module_i2c_driver(st_lsm6ds3_driver);
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics lsm6ds3 i2c driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_i2c_master.c b/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_i2c_master.c
new file mode 100755
index 0000000..38fb959
--- /dev/null
+++ b/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_i2c_master.c
@@ -0,0 +1,1781 @@
+/*
+ * STMicroelectronics lsm6ds3 i2c master driver
+ *
+ * Copyright 2014-2016 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/events.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/iio/triggered_buffer.h>
+#include <asm/unaligned.h>
+
+#include "st_lsm6ds3.h"
+
+#define EXT0_INDEX				0
+
+#define ST_LSM6DS3_ODR_LIST_NUM			4
+#define ST_LSM6DS3_SENSOR_HUB_OP_TIMEOUT	5
+#define ST_LSM6DS3_SRC_FUNC_ADDR		0x53
+#define ST_LSM6DS3_EN_BIT			0x01
+#define ST_LSM6DS3_DIS_BIT			0x00
+#define ST_LSM6DS3_SLV0_ADDR_ADDR		0x02
+#define ST_LSM6DS3_SLV1_ADDR_ADDR		0x05
+#define ST_LSM6DS3_SLV2_ADDR_ADDR		0x08
+#define ST_LSM6DS3_SLV0_OUT_ADDR		0x2e
+#define ST_LSM6DS3_INTER_PULLUP_ADDR		0x1a
+#define ST_LSM6DS3_INTER_PULLUP_MASK		0x08
+#define ST_LSM6DS3_FUNC_MAX_RATE_ADDR		0x18
+#define ST_LSM6DS3_FUNC_MAX_RATE_MASK		0x02
+#define ST_LSM6DS3_DATAWRITE_SLV0		0x0e
+#define ST_LSM6DS3_SLVX_READ			0x01
+
+/* External sensors configuration */
+#ifdef CONFIG_ST_LSM6DS3_IIO_EXT0_LIS3MDL
+static int lis3mdl_initialization(struct lsm6ds3_sensor_data *sdata);
+
+#define ST_LSM6DS3_EXT0_ADDR			0x1e
+#define ST_LSM6DS3_EXT0_ADDR2			0x1c
+#define ST_LSM6DS3_EXT0_WAI_ADDR		0x0f
+#define ST_LSM6DS3_EXT0_WAI_VALUE		0x3d
+#define ST_LSM6DS3_EXT0_RESET_ADDR		0x21
+#define ST_LSM6DS3_EXT0_RESET_MASK		0x04
+#define ST_LSM6DS3_EXT0_FULLSCALE_ADDR		0x21
+#define ST_LSM6DS3_EXT0_FULLSCALE_MASK		0x60
+#define ST_LSM6DS3_EXT0_FULLSCALE_VALUE		0x02
+#define ST_LSM6DS3_EXT0_ODR_ADDR		0x20
+#define ST_LSM6DS3_EXT0_ODR_MASK		0x1c
+#define ST_LSM6DS3_EXT0_ODR0_HZ			10
+#define ST_LSM6DS3_EXT0_ODR0_VALUE		0x04
+#define ST_LSM6DS3_EXT0_ODR1_HZ			20
+#define ST_LSM6DS3_EXT0_ODR1_VALUE		0x05
+#define ST_LSM6DS3_EXT0_ODR2_HZ			40
+#define ST_LSM6DS3_EXT0_ODR2_VALUE		0x06
+#define ST_LSM6DS3_EXT0_ODR3_HZ			80
+#define ST_LSM6DS3_EXT0_ODR3_VALUE		0x07
+#define ST_LSM6DS3_EXT0_PW_ADDR			0x22
+#define ST_LSM6DS3_EXT0_PW_MASK			0x03
+#define ST_LSM6DS3_EXT0_PW_OFF			0x02
+#define ST_LSM6DS3_EXT0_PW_ON			0x00
+#define ST_LSM6DS3_EXT0_GAIN_VALUE		438
+#define ST_LSM6DS3_EXT0_OUT_X_L_ADDR		0x28
+#define ST_LSM6DS3_EXT0_OUT_Y_L_ADDR		0x2a
+#define ST_LSM6DS3_EXT0_OUT_Z_L_ADDR		0x2c
+#define ST_LSM6DS3_EXT0_READ_DATA_LEN		6
+#define ST_LSM6DS3_EXT0_BDU_ADDR		0x24
+#define ST_LSM6DS3_EXT0_BDU_MASK		0x40
+#define ST_LSM6DS3_EXT0_STD			0
+#define ST_LSM6DS3_EXT0_BOOT_FUNCTION		(&lis3mdl_initialization)
+#define ST_LSM6DS3_SELFTEST_EXT0_MIN		2281
+#define ST_LSM6DS3_SELFTEST_EXT0_MAX		6843
+#define ST_LSM6DS3_SELFTEST_EXT0_MIN_Z		228
+#define ST_LSM6DS3_SELFTEST_EXT0_MAX_Z		2281
+#define ST_LSM6DS3_SELFTEST_ADDR1		0x20
+#define ST_LSM6DS3_SELFTEST_ADDR2		0x21
+#define ST_LSM6DS3_SELFTEST_ADDR3		0x22
+#define ST_LSM6DS3_SELFTEST_ADDR1_VALUE		0x1c
+#define ST_LSM6DS3_SELFTEST_ADDR2_VALUE		0x40
+#define ST_LSM6DS3_SELFTEST_ADDR3_VALUE		0x00
+#define ST_LSM6DS3_SELFTEST_ENABLE		0x1d
+#endif /* CONFIG_ST_LSM6DS3_IIO_EXT0_LIS3MDL */
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09911
+static int akm09911_initialization(struct lsm6ds3_sensor_data *sdata);
+
+#define ST_LSM6DS3_EXT0_ADDR			0x0c
+#define ST_LSM6DS3_EXT0_ADDR2			0x0d
+#define ST_LSM6DS3_EXT0_WAI_ADDR		0x01
+#define ST_LSM6DS3_EXT0_WAI_VALUE		0x05
+#define ST_LSM6DS3_EXT0_RESET_ADDR		0x32
+#define ST_LSM6DS3_EXT0_RESET_MASK		0x01
+#define ST_LSM6DS3_EXT0_FULLSCALE_ADDR		0x00
+#define ST_LSM6DS3_EXT0_FULLSCALE_MASK		0x00
+#define ST_LSM6DS3_EXT0_FULLSCALE_VALUE		0x00
+#define ST_LSM6DS3_EXT0_ODR_ADDR		0x31
+#define ST_LSM6DS3_EXT0_ODR_MASK		0x1f
+#define ST_LSM6DS3_EXT0_ODR0_HZ			10
+#define ST_LSM6DS3_EXT0_ODR0_VALUE		0x02
+#define ST_LSM6DS3_EXT0_ODR1_HZ			20
+#define ST_LSM6DS3_EXT0_ODR1_VALUE		0x04
+#define ST_LSM6DS3_EXT0_ODR2_HZ			50
+#define ST_LSM6DS3_EXT0_ODR2_VALUE		0x06
+#define ST_LSM6DS3_EXT0_ODR3_HZ			100
+#define ST_LSM6DS3_EXT0_ODR3_VALUE		0x08
+#define ST_LSM6DS3_EXT0_PW_ADDR			ST_LSM6DS3_EXT0_ODR_ADDR
+#define ST_LSM6DS3_EXT0_PW_MASK			ST_LSM6DS3_EXT0_ODR_MASK
+#define ST_LSM6DS3_EXT0_PW_OFF			0x00
+#define ST_LSM6DS3_EXT0_PW_ON			ST_LSM6DS3_EXT0_ODR0_VALUE
+#define ST_LSM6DS3_EXT0_GAIN_VALUE		6000
+#define ST_LSM6DS3_EXT0_OUT_X_L_ADDR		0x11
+#define ST_LSM6DS3_EXT0_OUT_Y_L_ADDR		0x13
+#define ST_LSM6DS3_EXT0_OUT_Z_L_ADDR		0x15
+#define ST_LSM6DS3_EXT0_READ_DATA_LEN		6
+#define ST_LSM6DS3_EXT0_SENSITIVITY_ADDR	0x60
+#define ST_LSM6DS3_EXT0_SENSITIVITY_LEN		3
+#define ST_LSM6DS3_EXT0_STD			0
+#define ST_LSM6DS3_EXT0_BOOT_FUNCTION		(&akm09911_initialization)
+#define ST_LSM6DS3_EXT0_DATA_STATUS		0x18
+#define ST_LSM6DS3_SELFTEST_EXT0_MIN		(-30)
+#define ST_LSM6DS3_SELFTEST_EXT0_MAX		30
+#define ST_LSM6DS3_SELFTEST_EXT0_MIN_Z		(-400)
+#define ST_LSM6DS3_SELFTEST_EXT0_MAX_Z		(-50)
+#endif /* CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09911 */
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09912
+static int akm09912_initialization(struct lsm6ds3_sensor_data *sdata);
+
+#define ST_LSM6DS3_EXT0_ADDR			0x0c
+#define ST_LSM6DS3_EXT0_ADDR2			0x0d
+#define ST_LSM6DS3_EXT0_WAI_ADDR		0x01
+#define ST_LSM6DS3_EXT0_WAI_VALUE		0x04
+#define ST_LSM6DS3_EXT0_RESET_ADDR		0x32
+#define ST_LSM6DS3_EXT0_RESET_MASK		0x01
+#define ST_LSM6DS3_EXT0_FULLSCALE_ADDR		0x00
+#define ST_LSM6DS3_EXT0_FULLSCALE_MASK		0x00
+#define ST_LSM6DS3_EXT0_FULLSCALE_VALUE		0x00
+#define ST_LSM6DS3_EXT0_ODR_ADDR		0x31
+#define ST_LSM6DS3_EXT0_ODR_MASK		0x1f
+#define ST_LSM6DS3_EXT0_ODR0_HZ			10
+#define ST_LSM6DS3_EXT0_ODR0_VALUE		0x02
+#define ST_LSM6DS3_EXT0_ODR1_HZ			20
+#define ST_LSM6DS3_EXT0_ODR1_VALUE		0x04
+#define ST_LSM6DS3_EXT0_ODR2_HZ			50
+#define ST_LSM6DS3_EXT0_ODR2_VALUE		0x06
+#define ST_LSM6DS3_EXT0_ODR3_HZ			100
+#define ST_LSM6DS3_EXT0_ODR3_VALUE		0x08
+#define ST_LSM6DS3_EXT0_PW_ADDR			ST_LSM6DS3_EXT0_ODR_ADDR
+#define ST_LSM6DS3_EXT0_PW_MASK			ST_LSM6DS3_EXT0_ODR_MASK
+#define ST_LSM6DS3_EXT0_PW_OFF			0x00
+#define ST_LSM6DS3_EXT0_PW_ON			ST_LSM6DS3_EXT0_ODR0_VALUE
+#define ST_LSM6DS3_EXT0_GAIN_VALUE		1500
+#define ST_LSM6DS3_EXT0_OUT_X_L_ADDR		0x11
+#define ST_LSM6DS3_EXT0_OUT_Y_L_ADDR		0x13
+#define ST_LSM6DS3_EXT0_OUT_Z_L_ADDR		0x15
+#define ST_LSM6DS3_EXT0_READ_DATA_LEN		6
+#define ST_LSM6DS3_EXT0_SENSITIVITY_ADDR	0x60
+#define ST_LSM6DS3_EXT0_SENSITIVITY_LEN		3
+#define ST_LSM6DS3_EXT0_STD			0
+#define ST_LSM6DS3_EXT0_BOOT_FUNCTION		(&akm09912_initialization)
+#define ST_LSM6DS3_EXT0_DATA_STATUS		0x18
+#define ST_LSM6DS3_SELFTEST_EXT0_MIN		(-200)
+#define ST_LSM6DS3_SELFTEST_EXT0_MAX		200
+#define ST_LSM6DS3_SELFTEST_EXT0_MIN_Z		(-1600)
+#define ST_LSM6DS3_SELFTEST_EXT0_MAX_Z		(-400)
+#endif /* CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09912 */
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09916
+#define ST_LSM6DS3_EXT0_ADDR			0x0c
+#define ST_LSM6DS3_EXT0_ADDR2			0x0c
+#define ST_LSM6DS3_EXT0_WAI_ADDR		0x01
+#define ST_LSM6DS3_EXT0_WAI_VALUE		0x09
+#define ST_LSM6DS3_EXT0_RESET_ADDR		0x32
+#define ST_LSM6DS3_EXT0_RESET_MASK		0x01
+#define ST_LSM6DS3_EXT0_FULLSCALE_ADDR		0x00
+#define ST_LSM6DS3_EXT0_FULLSCALE_MASK		0x00
+#define ST_LSM6DS3_EXT0_FULLSCALE_VALUE		0x00
+#define ST_LSM6DS3_EXT0_ODR_ADDR		0x31
+#define ST_LSM6DS3_EXT0_ODR_MASK		0x1f
+#define ST_LSM6DS3_EXT0_ODR0_HZ			10
+#define ST_LSM6DS3_EXT0_ODR0_VALUE		0x02
+#define ST_LSM6DS3_EXT0_ODR1_HZ			20
+#define ST_LSM6DS3_EXT0_ODR1_VALUE		0x04
+#define ST_LSM6DS3_EXT0_ODR2_HZ			50
+#define ST_LSM6DS3_EXT0_ODR2_VALUE		0x06
+#define ST_LSM6DS3_EXT0_ODR3_HZ			100
+#define ST_LSM6DS3_EXT0_ODR3_VALUE		0x08
+#define ST_LSM6DS3_EXT0_PW_ADDR			ST_LSM6DS3_EXT0_ODR_ADDR
+#define ST_LSM6DS3_EXT0_PW_MASK			ST_LSM6DS3_EXT0_ODR_MASK
+#define ST_LSM6DS3_EXT0_PW_OFF			0x00
+#define ST_LSM6DS3_EXT0_PW_ON			ST_LSM6DS3_EXT0_ODR0_VALUE
+#define ST_LSM6DS3_EXT0_GAIN_VALUE		1500
+#define ST_LSM6DS3_EXT0_OUT_X_L_ADDR		0x11
+#define ST_LSM6DS3_EXT0_OUT_Y_L_ADDR		0x13
+#define ST_LSM6DS3_EXT0_OUT_Z_L_ADDR		0x15
+#define ST_LSM6DS3_EXT0_READ_DATA_LEN		6
+#define ST_LSM6DS3_EXT0_SENSITIVITY_ADDR	0x60
+#define ST_LSM6DS3_EXT0_SENSITIVITY_LEN		3
+#define ST_LSM6DS3_EXT0_STD			0
+#define ST_LSM6DS3_EXT0_BOOT_FUNCTION		NULL
+#define ST_LSM6DS3_EXT0_DATA_STATUS		0x18
+#define ST_LSM6DS3_SELFTEST_EXT0_MIN		(-200)
+#define ST_LSM6DS3_SELFTEST_EXT0_MAX		200
+#define ST_LSM6DS3_SELFTEST_EXT0_MIN_Z		(-1000)
+#define ST_LSM6DS3_SELFTEST_EXT0_MAX_Z		(-200)
+#endif /* CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09916 */
+
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_EXT0_LPS22HB
+static int lps22hb_initialization(struct lsm6ds3_sensor_data *sdata);
+
+#define ST_LSM6DS3_EXT0_ADDR			0x5d
+#define ST_LSM6DS3_EXT0_ADDR2			0x5c
+#define ST_LSM6DS3_EXT0_WAI_ADDR		0x0f
+#define ST_LSM6DS3_EXT0_WAI_VALUE		0xb1
+#define ST_LSM6DS3_EXT0_RESET_ADDR		0x11
+#define ST_LSM6DS3_EXT0_RESET_MASK		0x80
+#define ST_LSM6DS3_EXT0_FULLSCALE_ADDR		0x00
+#define ST_LSM6DS3_EXT0_FULLSCALE_MASK		0x00
+#define ST_LSM6DS3_EXT0_FULLSCALE_VALUE		0x00
+#define ST_LSM6DS3_EXT0_ODR_ADDR		0x10
+#define ST_LSM6DS3_EXT0_ODR_MASK		0x70
+#define ST_LSM6DS3_EXT0_ODR0_HZ			1
+#define ST_LSM6DS3_EXT0_ODR0_VALUE		0x01
+#define ST_LSM6DS3_EXT0_ODR1_HZ			10
+#define ST_LSM6DS3_EXT0_ODR1_VALUE		0x02
+#define ST_LSM6DS3_EXT0_ODR2_HZ			25
+#define ST_LSM6DS3_EXT0_ODR2_VALUE		0x03
+#define ST_LSM6DS3_EXT0_ODR3_HZ			50
+#define ST_LSM6DS3_EXT0_ODR3_VALUE		0x04
+#define ST_LSM6DS3_EXT0_PW_ADDR			ST_LSM6DS3_EXT0_ODR_ADDR
+#define ST_LSM6DS3_EXT0_PW_MASK			ST_LSM6DS3_EXT0_ODR_MASK
+#define ST_LSM6DS3_EXT0_PW_OFF			0x00
+#define ST_LSM6DS3_EXT0_PW_ON			ST_LSM6DS3_EXT0_ODR0_VALUE
+#define ST_LSM6DS3_EXT0_GAIN_VALUE		244
+#define ST_LSM6DS3_EXT0_OUT_P_L_ADDR		0x28
+#define ST_LSM6DS3_EXT0_OUT_T_L_ADDR		0x2b
+#define ST_LSM6DS3_EXT0_READ_DATA_LEN		5
+#define ST_LSM6DS3_EXT0_BDU_ADDR		0x10
+#define ST_LSM6DS3_EXT0_BDU_MASK		0x02
+#define ST_LSM6DS3_EXT0_STD			0
+#define ST_LSM6DS3_EXT0_BOOT_FUNCTION		(&lps22hb_initialization)
+#endif /* CONFIG_ST_LSM6DS3_IIO_EXT0_LPS22HB */
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_EXT0_LIS2MDL
+static int lis2mdl_initialization(struct lsm6ds3_sensor_data *sdata);
+
+#define ST_LSM6DS3_EXT0_ADDR			0x1e
+#define ST_LSM6DS3_EXT0_ADDR2			0x1e
+#define ST_LSM6DS3_EXT0_WAI_ADDR		0x4f
+#define ST_LSM6DS3_EXT0_WAI_VALUE		0x40
+#define ST_LSM6DS3_EXT0_RESET_ADDR		0x60
+#define ST_LSM6DS3_EXT0_RESET_MASK		0x20
+#define ST_LSM6DS3_EXT0_ODR_ADDR		0x60
+#define ST_LSM6DS3_EXT0_ODR_MASK		0x0c
+#define ST_LSM6DS3_EXT0_ODR0_HZ			10
+#define ST_LSM6DS3_EXT0_ODR0_VALUE		0x00
+#define ST_LSM6DS3_EXT0_ODR1_HZ			20
+#define ST_LSM6DS3_EXT0_ODR1_VALUE		0x01
+#define ST_LSM6DS3_EXT0_ODR2_HZ			50
+#define ST_LSM6DS3_EXT0_ODR2_VALUE		0x02
+#define ST_LSM6DS3_EXT0_ODR3_HZ			100
+#define ST_LSM6DS3_EXT0_ODR3_VALUE		0x03
+#define ST_LSM6DS3_EXT0_PW_ADDR			0x60
+#define ST_LSM6DS3_EXT0_PW_MASK			0x03
+#define ST_LSM6DS3_EXT0_PW_OFF			0x02
+#define ST_LSM6DS3_EXT0_PW_ON			0x00
+#define ST_LSM6DS3_EXT0_GAIN_VALUE		1500
+#define ST_LSM6DS3_EXT0_OUT_X_L_ADDR		0x68
+#define ST_LSM6DS3_EXT0_OUT_Y_L_ADDR		0x6a
+#define ST_LSM6DS3_EXT0_OUT_Z_L_ADDR		0x6c
+#define ST_LSM6DS3_EXT0_READ_DATA_LEN		6
+#define ST_LSM6DS3_EXT0_BDU_ADDR		0x62
+#define ST_LSM6DS3_EXT0_BDU_MASK		0x10
+#define ST_LSM6DS3_EXT0_STD			6
+#define ST_LSM6DS3_EXT0_TEMP_COMP_ADDR		0x60
+#define ST_LSM6DS3_EXT0_TEMP_COMP_MASK		0x80
+#define ST_LSM6DS3_EXT0_OFF_CANC_ADDR		0x61
+#define ST_LSM6DS3_EXT0_OFF_CANC_MASK		0x02
+#define ST_LSM6DS3_EXT0_BOOT_FUNCTION		(&lis2mdl_initialization)
+#endif /* CONFIG_ST_LSM6DS3_IIO_EXT0_LIS2MDL */
+
+/* SENSORS SUFFIX NAMES */
+#define ST_LSM6DS3_EXT0_SUFFIX_NAME		"magn"
+#define ST_LSM6DS3_EXT1_SUFFIX_NAME		"press"
+
+#if defined(CONFIG_ST_LSM6DS3_IIO_EXT0_LIS3MDL) || \
+			defined(CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09912) || \
+			defined(CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09916) || \
+			defined(CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09911)
+#define ST_LSM6DS3_EXT0_HAS_SELFTEST		1
+#endif /* CONFIG_ST_LSM6DS3_IIO_EXT0_MAGN */
+
+#if defined(CONFIG_ST_LSM6DS3_IIO_EXT0_LIS3MDL) || \
+    defined(CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09912) || \
+    defined(CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09916) || \
+    defined(CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09911) || \
+    defined(CONFIG_ST_LSM6DS3_IIO_EXT0_LPS22HB)
+#define ST_LSM6DS3_EXT0_HAS_FULLSCALE		1
+#endif
+
+#if defined(CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09912) || \
+			defined(CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09916) || \
+			defined(CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09911)
+#define ST_LSM6DS3_EXT0_IS_AKM			1
+#define ST_LSM6DS3_SELFTEST_STATUS_REG		0x10
+#define ST_LSM6DS3_SELFTEST_ADDR		0x31
+#define ST_LSM6DS3_SELFTEST_ENABLE		0x10
+#endif /* CONFIG_ST_LSM6DS3_IIO_EXT0_AKM0099xx */
+
+
+struct st_lsm6ds3_i2c_master_odr_reg {
+	unsigned int hz;
+	u8 value;
+};
+
+struct st_lsm6ds3_i2c_master_odr_table {
+	u8 addr;
+	u8 mask;
+	struct st_lsm6ds3_i2c_master_odr_reg odr_avl[ST_LSM6DS3_ODR_LIST_NUM];
+};
+
+static int st_lsm6ds3_i2c_master_read_raw(struct iio_dev *indio_dev,
+		struct iio_chan_spec const *ch, int *val, int *val2, long mask);
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_EXT0_LPS22HB
+static const struct iio_chan_spec st_lsm6ds3_ext0_ch[] = {
+	ST_LSM6DS3_LSM_CHANNELS(IIO_PRESSURE, 0, 0, IIO_NO_MOD, IIO_LE,
+				24, 24, ST_LSM6DS3_EXT0_OUT_P_L_ADDR, 'u'),
+	ST_LSM6DS3_LSM_CHANNELS(IIO_TEMP, 0, 1, IIO_NO_MOD, IIO_LE,
+				16, 16, ST_LSM6DS3_EXT0_OUT_T_L_ADDR, 's'),
+	ST_LSM6DS3_FLUSH_CHANNEL(IIO_PRESSURE),
+	IIO_CHAN_SOFT_TIMESTAMP(2)
+};
+#else /* CONFIG_ST_LSM6DS3_IIO_EXT0_LPS22HB */
+static const struct iio_chan_spec st_lsm6ds3_ext0_ch[] = {
+	ST_LSM6DS3_LSM_CHANNELS(IIO_MAGN, 1, 0, IIO_MOD_X, IIO_LE,
+				16, 16, ST_LSM6DS3_EXT0_OUT_X_L_ADDR, 's'),
+	ST_LSM6DS3_LSM_CHANNELS(IIO_MAGN, 1, 1, IIO_MOD_Y, IIO_LE,
+				16, 16, ST_LSM6DS3_EXT0_OUT_Y_L_ADDR, 's'),
+	ST_LSM6DS3_LSM_CHANNELS(IIO_MAGN, 1, 2, IIO_MOD_Z, IIO_LE,
+				16, 16, ST_LSM6DS3_EXT0_OUT_Z_L_ADDR, 's'),
+	ST_LSM6DS3_FLUSH_CHANNEL(IIO_MAGN),
+	IIO_CHAN_SOFT_TIMESTAMP(3)
+};
+#endif /* CONFIG_ST_LSM6DS3_IIO_EXT0_LPS22HB */
+
+static int st_lsm6ds3_i2c_master_set_odr(struct lsm6ds3_sensor_data *sdata,
+						unsigned int odr, bool force);
+
+static int st_lsm6ds3_i2c_master_write(struct lsm6ds3_data *cdata,
+		u8 reg_addr, int len, u8 *data, bool en_sensor_hub, bool transfer_lock);
+static int st_lsm6ds3_i2c_master_read(struct lsm6ds3_data *cdata,
+		u8 reg_addr, int len, u8 *data, bool en_sensor_hub,
+				bool transfer_lock, bool read_status_end, u8 offset);
+
+#ifdef ST_LSM6DS3_EXT0_HAS_SELFTEST
+static ssize_t st_lsm6ds3_i2c_master_sysfs_get_selftest_available(
+		struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t st_lsm6ds3_i2c_master_sysfs_get_selftest_status(
+		struct device *dev, struct device_attribute *attr, char *buf);
+static ssize_t st_lsm6ds3_i2c_master_sysfs_start_selftest(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size);
+#endif /* ST_LSM6DS3_EXT0_HAS_SELFTEST	*/
+
+static ssize_t st_lsm6ds3_i2c_master_sysfs_sampling_frequency_avail(
+		struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE,
+			"%d %d %d %d\n", 13, 26, 52, 104);
+}
+
+static ssize_t st_lsm6ds3_i2c_master_sysfs_get_sampling_frequency(
+		struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct lsm6ds3_sensor_data *sdata = iio_priv(dev_get_drvdata(dev));
+
+	return sprintf(buf, "%d\n", sdata->cdata->v_odr[sdata->sindex]);
+}
+
+static ssize_t st_lsm6ds3_i2c_master_sysfs_set_sampling_frequency(
+			struct device *dev, struct device_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned int odr;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = kstrtoint(buf, 10, &odr);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&indio_dev->mlock);
+	mutex_lock(&sdata->cdata->odr_lock);
+
+	if (sdata->cdata->v_odr[sdata->sindex] != odr)
+		err = st_lsm6ds3_i2c_master_set_odr(sdata, odr, false);
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+	mutex_unlock(&indio_dev->mlock);
+
+	return err < 0 ? err : size;
+}
+
+static IIO_DEV_ATTR_SAMP_FREQ(S_IWUSR | S_IRUGO,
+			st_lsm6ds3_i2c_master_sysfs_get_sampling_frequency,
+			st_lsm6ds3_i2c_master_sysfs_set_sampling_frequency);
+
+static IIO_DEV_ATTR_SAMP_FREQ_AVAIL(
+			st_lsm6ds3_i2c_master_sysfs_sampling_frequency_avail);
+
+static ST_LSM6DS3_HWFIFO_ENABLED();
+static ST_LSM6DS3_HWFIFO_WATERMARK();
+static ST_LSM6DS3_HWFIFO_WATERMARK_MIN();
+static ST_LSM6DS3_HWFIFO_WATERMARK_MAX();
+static ST_LSM6DS3_HWFIFO_FLUSH();
+
+#ifdef ST_LSM6DS3_EXT0_HAS_SELFTEST
+static IIO_DEVICE_ATTR(selftest_available, S_IRUGO,
+			st_lsm6ds3_i2c_master_sysfs_get_selftest_available,
+			NULL, 0);
+
+static IIO_DEVICE_ATTR(selftest, S_IWUSR | S_IRUGO,
+			st_lsm6ds3_i2c_master_sysfs_get_selftest_status,
+			st_lsm6ds3_i2c_master_sysfs_start_selftest, 0);
+#endif /* ST_LSM6DS3_EXT0_HAS_SELFTEST	*/
+
+static struct attribute *st_lsm6ds3_ext0_attributes[] = {
+	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_dev_attr_sampling_frequency.dev_attr.attr,
+	&iio_dev_attr_hwfifo_enabled.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_min.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_max.dev_attr.attr,
+	&iio_dev_attr_hwfifo_flush.dev_attr.attr,
+#ifdef ST_LSM6DS3_EXT0_HAS_SELFTEST
+	&iio_dev_attr_selftest_available.dev_attr.attr,
+	&iio_dev_attr_selftest.dev_attr.attr,
+#endif /* ST_LSM6DS3_EXT0_HAS_SELFTEST	*/
+	NULL,
+};
+
+static const struct attribute_group st_lsm6ds3_ext0_attribute_group = {
+	.attrs = st_lsm6ds3_ext0_attributes,
+};
+
+static const struct iio_info st_lsm6ds3_ext0_info = {
+	.driver_module = THIS_MODULE,
+	.attrs = &st_lsm6ds3_ext0_attribute_group,
+	.read_raw = &st_lsm6ds3_i2c_master_read_raw,
+};
+
+struct st_lsm6ds3_iio_info_data {
+	char suffix_name[20];
+	struct iio_info *info;
+	struct iio_chan_spec *channels;
+	int num_channels;
+};
+
+struct st_lsm6ds3_reg {
+	u8 addr;
+	u8 mask;
+	u8 def_value;
+};
+
+struct st_lsm6ds3_power_reg {
+	u8 addr;
+	u8 mask;
+	u8 off_value;
+	u8 on_value;
+	bool isodr;
+};
+
+struct st_lsm6ds3_custom_function {
+	int (*boot_initialization)(struct lsm6ds3_sensor_data *sdata);
+};
+
+static struct st_lsm6ds3_exs_list {
+	struct st_lsm6ds3_reg wai;
+	struct st_lsm6ds3_reg reset;
+	struct st_lsm6ds3_reg fullscale;
+	struct st_lsm6ds3_i2c_master_odr_table odr;
+	struct st_lsm6ds3_power_reg power;
+	u8 fullscale_value;
+	u8 samples_to_discard;
+	u8 read_data_len;
+	u8 num_data_channels;
+	bool available;
+	unsigned int gain;
+	u8 i2c_addr;
+	struct st_lsm6ds3_iio_info_data data;
+	struct st_lsm6ds3_custom_function cf;
+} st_lsm6ds3_exs_list[] = {
+	{
+		.wai = {
+			.addr = ST_LSM6DS3_EXT0_WAI_ADDR,
+			.def_value = ST_LSM6DS3_EXT0_WAI_VALUE,
+		},
+		.reset = {
+			.addr = ST_LSM6DS3_EXT0_RESET_ADDR,
+			.mask = ST_LSM6DS3_EXT0_RESET_MASK,
+		},
+#ifdef ST_LSM6DS3_EXT0_HAS_FULLSCALE
+		.fullscale = {
+			.addr = ST_LSM6DS3_EXT0_FULLSCALE_ADDR,
+			.mask = ST_LSM6DS3_EXT0_FULLSCALE_MASK,
+			.def_value = ST_LSM6DS3_EXT0_FULLSCALE_VALUE,
+		},
+#endif
+		.odr = {
+			.addr = ST_LSM6DS3_EXT0_ODR_ADDR,
+			.mask = ST_LSM6DS3_EXT0_ODR_MASK,
+			.odr_avl = {
+				{
+				.hz = ST_LSM6DS3_EXT0_ODR0_HZ,
+				.value = ST_LSM6DS3_EXT0_ODR0_VALUE,
+				},
+				{
+				.hz = ST_LSM6DS3_EXT0_ODR1_HZ,
+				.value = ST_LSM6DS3_EXT0_ODR1_VALUE,
+				},
+				{
+				.hz = ST_LSM6DS3_EXT0_ODR2_HZ,
+				.value = ST_LSM6DS3_EXT0_ODR2_VALUE,
+				},
+				{
+				.hz = ST_LSM6DS3_EXT0_ODR3_HZ,
+				.value = ST_LSM6DS3_EXT0_ODR3_VALUE,
+				},
+			},
+		},
+		.power = {
+			.addr = ST_LSM6DS3_EXT0_PW_ADDR,
+			.mask = ST_LSM6DS3_EXT0_PW_MASK,
+			.off_value = ST_LSM6DS3_EXT0_PW_OFF,
+			.on_value = ST_LSM6DS3_EXT0_PW_ON,
+		},
+		.samples_to_discard = ST_LSM6DS3_EXT0_STD,
+		.read_data_len = ST_LSM6DS3_EXT0_READ_DATA_LEN,
+		.num_data_channels = 3,
+		.available = false,
+		.gain = ST_LSM6DS3_EXT0_GAIN_VALUE,
+		.i2c_addr = ST_LSM6DS3_EXT0_ADDR,
+		.data = {
+			.suffix_name = ST_LSM6DS3_EXT0_SUFFIX_NAME,
+			.info = (struct iio_info *)&st_lsm6ds3_ext0_info,
+			.channels = (struct iio_chan_spec *)&st_lsm6ds3_ext0_ch,
+			.num_channels = ARRAY_SIZE(st_lsm6ds3_ext0_ch),
+		},
+		.cf.boot_initialization = ST_LSM6DS3_EXT0_BOOT_FUNCTION,
+	}
+};
+
+static inline void st_lsm6ds3_master_wait_completed(struct lsm6ds3_data *cdata)
+{
+	msleep((1000U / cdata->trigger_odr) + 2);
+}
+
+static int st_lsm6ds3_i2c_master_read(struct lsm6ds3_data *cdata,
+		u8 reg_addr, int len, u8 *data, bool en_sensor_hub,
+			bool transfer_lock, bool read_status_end, u8 offset)
+{
+	int err;
+	u8 slave_conf[3];
+
+	slave_conf[0] = (st_lsm6ds3_exs_list[EXT0_INDEX].i2c_addr << 1) |
+							ST_LSM6DS3_SLVX_READ;
+	slave_conf[1] = reg_addr;
+	slave_conf[2] = (len & 0x07);
+
+	if (transfer_lock)
+		mutex_lock(&cdata->i2c_transfer_lock);
+
+	err = st_lsm6ds3_write_embedded_registers(cdata,
+					ST_LSM6DS3_SLV2_ADDR_ADDR, slave_conf,
+					ARRAY_SIZE(slave_conf));
+	if (err < 0)
+		goto i2c_master_read_unlock_mutex;
+
+	if (en_sensor_hub) {
+		err = st_lsm6ds3_enable_sensor_hub(cdata, true,
+						ST_MASK_ID_SENSOR_HUB_ASYNC_OP);
+		if (err < 0)
+			goto i2c_master_read_unlock_mutex;
+	}
+
+	st_lsm6ds3_master_wait_completed(cdata);
+
+	err = cdata->tf->read(cdata, ST_LSM6DS3_SLV0_OUT_ADDR +
+					offset, len & 0x07, data, true);
+	if (err < 0)
+		goto i2c_master_read_unlock_mutex;
+
+#ifdef ST_LSM6DS3_EXT0_IS_AKM
+	if (read_status_end) {
+		slave_conf[0] = (st_lsm6ds3_exs_list[EXT0_INDEX].i2c_addr << 1) | 0x01;
+		slave_conf[1] = ST_LSM6DS3_EXT0_DATA_STATUS;
+		slave_conf[2] = 0x01;
+
+		err = st_lsm6ds3_write_embedded_registers(cdata,
+					ST_LSM6DS3_SLV2_ADDR_ADDR, slave_conf,
+					ARRAY_SIZE(slave_conf));
+		if (err < 0)
+			goto i2c_master_read_unlock_mutex;
+	}
+#endif /* ST_LSM6DS3_EXT0_IS_AKM */
+
+	if (en_sensor_hub) {
+		err = st_lsm6ds3_enable_sensor_hub(cdata, false,
+						ST_MASK_ID_SENSOR_HUB_ASYNC_OP);
+		if (err < 0)
+			goto i2c_master_read_unlock_mutex;
+	}
+
+i2c_master_read_unlock_mutex:
+	if (transfer_lock)
+		mutex_unlock(&cdata->i2c_transfer_lock);
+
+	return err < 0 ? err : len & 0x07;
+}
+
+static int st_lsm6ds3_i2c_master_write(struct lsm6ds3_data *cdata,
+		u8 reg_addr, int len, u8 *data, bool en_sensor_hub, bool transfer_lock)
+{
+	int err, i = 0;
+	u8 slave0_conf[2];
+
+	if (transfer_lock)
+		mutex_lock(&cdata->i2c_transfer_lock);
+
+	while (i < len) {
+		slave0_conf[0] = (st_lsm6ds3_exs_list[EXT0_INDEX].i2c_addr << 1);
+		slave0_conf[1] = reg_addr + i;
+
+		err = st_lsm6ds3_write_embedded_registers(cdata,
+						ST_LSM6DS3_SLV0_ADDR_ADDR,
+						slave0_conf,
+						ARRAY_SIZE(slave0_conf));
+		if (err < 0)
+			goto i2c_master_write_unlock_mutex;
+
+		slave0_conf[0] = data[i];
+
+		err = st_lsm6ds3_write_embedded_registers(cdata,
+						ST_LSM6DS3_DATAWRITE_SLV0,
+						slave0_conf, 1);
+		if (err < 0)
+			goto i2c_master_write_unlock_mutex;
+
+		if (en_sensor_hub) {
+			err = st_lsm6ds3_enable_sensor_hub(cdata, true,
+						ST_MASK_ID_SENSOR_HUB_ASYNC_OP);
+			if (err < 0)
+				goto i2c_master_write_unlock_mutex;
+		}
+
+		st_lsm6ds3_master_wait_completed(cdata);
+
+		if (en_sensor_hub) {
+			err = st_lsm6ds3_enable_sensor_hub(cdata, false,
+						ST_MASK_ID_SENSOR_HUB_ASYNC_OP);
+			if (err < 0)
+				goto i2c_master_write_unlock_mutex;
+		}
+
+		i++;
+	}
+
+	slave0_conf[0] = (st_lsm6ds3_exs_list[EXT0_INDEX].i2c_addr << 1);
+	slave0_conf[1] = st_lsm6ds3_exs_list[EXT0_INDEX].wai.addr;
+
+	st_lsm6ds3_write_embedded_registers(cdata,
+						ST_LSM6DS3_SLV0_ADDR_ADDR,
+						slave0_conf,
+						ARRAY_SIZE(slave0_conf));
+
+i2c_master_write_unlock_mutex:
+	if (transfer_lock)
+		mutex_unlock(&cdata->i2c_transfer_lock);
+
+	return err < 0 ? err : len;
+}
+
+static int st_lsm6ds3_i2c_master_write_data_with_mask(
+		struct lsm6ds3_data *cdata, u8 reg_addr, u8 mask, u8 data)
+{
+	int err;
+	u8 new_data = 0x00, old_data = 0x00;
+
+	mutex_lock(&cdata->i2c_transfer_lock);
+	disable_irq(cdata->irq);
+
+	err = st_lsm6ds3_enable_sensor_hub(cdata, true,
+						ST_MASK_ID_SENSOR_HUB_ASYNC_OP);
+	if (err < 0) {
+		enable_irq(cdata->irq);
+		mutex_unlock(&cdata->i2c_transfer_lock);
+		return err;
+	}
+
+	err = st_lsm6ds3_i2c_master_read(cdata, reg_addr, 1,
+					&old_data, false, false, true,
+					st_lsm6ds3_exs_list[0].read_data_len);
+	if (err < 0) {
+		enable_irq(cdata->irq);
+		mutex_unlock(&cdata->i2c_transfer_lock);
+		return err;
+	}
+
+	new_data = ((old_data & (~mask)) | ((data << __ffs(mask)) & mask));
+
+	if (new_data != old_data)
+		err = st_lsm6ds3_i2c_master_write(cdata, reg_addr,
+						1, &new_data, false, false);
+
+	st_lsm6ds3_enable_sensor_hub(cdata, false,
+						ST_MASK_ID_SENSOR_HUB_ASYNC_OP);
+
+	enable_irq(cdata->irq);
+	mutex_unlock(&cdata->i2c_transfer_lock);
+
+	return err;
+}
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_EXT0_LIS3MDL
+static int lis3mdl_initialization(struct lsm6ds3_sensor_data *sdata)
+{
+
+	return st_lsm6ds3_i2c_master_write_data_with_mask(
+				sdata->cdata,
+				ST_LSM6DS3_EXT0_BDU_ADDR,
+				ST_LSM6DS3_EXT0_BDU_MASK, ST_LSM6DS3_EN_BIT);
+}
+#endif /* CONFIG_ST_LSM6DS3_IIO_EXT0_LIS3MDL */
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09911
+static int akm09911_initialization(struct lsm6ds3_sensor_data *sdata)
+{
+	int err; u8 data[ST_LSM6DS3_EXT0_SENSITIVITY_LEN];
+
+	err = st_lsm6ds3_i2c_master_read(sdata->cdata,
+				ST_LSM6DS3_EXT0_SENSITIVITY_ADDR,
+				ST_LSM6DS3_EXT0_SENSITIVITY_LEN,
+				data, true, true, false,
+				st_lsm6ds3_exs_list[0].read_data_len);
+	if (err < 0)
+		return err;
+
+	/* gain expressed in nT/LSB */
+	sdata->c_gain[0] = (((((int)data[0]) * 1000) >> 7) + 1000);
+	sdata->c_gain[1] = (((((int)data[1]) * 1000) >> 7) + 1000);
+	sdata->c_gain[2] = (((((int)data[2]) * 1000) >> 7) + 1000);
+
+	/* gain expressed in G/LSB */
+	sdata->c_gain[0] *= 10;
+	sdata->c_gain[1] *= 10;
+	sdata->c_gain[2] *= 10;
+
+	return 0;
+}
+#endif /* CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09911 */
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09912
+static int akm09912_initialization(struct lsm6ds3_sensor_data *sdata)
+{
+	int err; u8 data[ST_LSM6DS3_EXT0_SENSITIVITY_LEN];
+
+	err = st_lsm6ds3_i2c_master_read(sdata->cdata,
+				ST_LSM6DS3_EXT0_SENSITIVITY_ADDR,
+				ST_LSM6DS3_EXT0_SENSITIVITY_LEN,
+				data, true, true, false,
+				st_lsm6ds3_exs_list[0].read_data_len);
+	if (err < 0)
+		return err;
+
+	/* gain expressed in nT/LSB */
+	sdata->c_gain[0] = (((((int)data[0] - 128) * 500) >> 7) + 1000);
+	sdata->c_gain[1] = (((((int)data[1] - 128) * 500) >> 7) + 1000);
+	sdata->c_gain[2] = (((((int)data[2] - 128) * 500) >> 7) + 1000);
+
+	/* gain expressed in G/LSB */
+	sdata->c_gain[0] *= 10;
+	sdata->c_gain[1] *= 10;
+	sdata->c_gain[2] *= 10;
+
+	return 0;
+}
+#endif /* CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09912 */
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_EXT0_LPS22HB
+static int lps22hb_initialization(struct lsm6ds3_sensor_data *sdata)
+{
+
+	return st_lsm6ds3_i2c_master_write_data_with_mask(
+				sdata->cdata,
+				ST_LSM6DS3_EXT0_BDU_ADDR,
+				ST_LSM6DS3_EXT0_BDU_MASK, ST_LSM6DS3_EN_BIT);
+}
+#endif /* CONFIG_ST_LSM6DS3_IIO_EXT0_LPS22HB */
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_EXT0_LIS2MDL
+static int lis2mdl_initialization(struct lsm6ds3_sensor_data *sdata)
+{
+	int err;
+
+	err = st_lsm6ds3_i2c_master_write_data_with_mask(sdata->cdata,
+						ST_LSM6DS3_EXT0_TEMP_COMP_ADDR,
+						ST_LSM6DS3_EXT0_TEMP_COMP_MASK,
+						1);
+	if (err < 0)
+		return err;
+
+	err = st_lsm6ds3_i2c_master_write_data_with_mask(sdata->cdata,
+						ST_LSM6DS3_EXT0_OFF_CANC_ADDR,
+						ST_LSM6DS3_EXT0_OFF_CANC_MASK,
+						1);
+	if (err < 0)
+		return err;
+
+	return st_lsm6ds3_i2c_master_write_data_with_mask(sdata->cdata,
+						ST_LSM6DS3_EXT0_BDU_ADDR,
+						ST_LSM6DS3_EXT0_BDU_MASK,
+						ST_LSM6DS3_EN_BIT);
+}
+#endif /* CONFIG_ST_LSM6DS3_IIO_EXT0_LIS2MDL */
+
+#ifdef ST_LSM6DS3_EXT0_HAS_SELFTEST
+static ssize_t st_lsm6ds3_i2c_master_sysfs_get_selftest_available(
+		struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "absolute\n");
+}
+
+static ssize_t st_lsm6ds3_i2c_master_sysfs_get_selftest_status(
+		struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int8_t result;
+	char *message;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	mutex_lock(&sdata->cdata->odr_lock);
+	result = sdata->cdata->ext0_selftest_status;
+	mutex_unlock(&sdata->cdata->odr_lock);
+
+	if (result == 0)
+		message = ST_LSM6DS3_SELFTEST_NA_MS;
+	else if (result < 0)
+		message = ST_LSM6DS3_SELFTEST_FAIL_MS;
+	else if (result > 0)
+		message = ST_LSM6DS3_SELFTEST_PASS_MS;
+
+	return sprintf(buf, "%s\n", message);
+}
+
+static ssize_t st_lsm6ds3_i2c_master_sysfs_start_selftest(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int err;
+	int x_selftest = 0, y_selftest = 0, z_selftest = 0;
+	u8 outdata[8], reg_addr, reg_status = 0, temp_reg_status;
+#ifdef CONFIG_ST_LSM6DS3_IIO_EXT0_LIS3MDL
+	int i, x = 0, y = 0, z = 0;
+	u8 reg_status2 = 0, reg_status3 = 0;
+	u8 reg_addr2, reg_addr3, temp_reg_status2, temp_reg_status3;
+#endif /* CONFIG_ST_LSM6DS3_IIO_EXT0_LIS3MDL */
+#ifdef ST_LSM6DS3_EXT0_IS_AKM
+	u8 temp, sh_config[3], timeout = 0;
+#endif /* ST_LSM6DS3_EXT0_IS_AKM */
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	mutex_lock(&sdata->cdata->odr_lock);
+	sdata->cdata->ext0_selftest_status = 0;
+
+	if (sdata->cdata->sensors_enabled > 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return -EBUSY;
+	}
+
+	if (strncmp(buf, "absolute", size - 2) != 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return -EINVAL;
+	}
+
+	err = st_lsm6ds3_enable_sensor_hub(sdata->cdata, true, ST_MASK_ID_EXT0);
+	if (err < 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return err;
+	}
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_EXT0_LIS3MDL
+	reg_addr = ST_LSM6DS3_SELFTEST_ADDR1;
+	temp_reg_status = ST_LSM6DS3_SELFTEST_ADDR1_VALUE;
+	reg_addr2 = ST_LSM6DS3_SELFTEST_ADDR2;
+	temp_reg_status2 = ST_LSM6DS3_SELFTEST_ADDR2_VALUE;
+	reg_addr3 = ST_LSM6DS3_SELFTEST_ADDR3;
+	temp_reg_status3 = ST_LSM6DS3_SELFTEST_ADDR3_VALUE;
+#endif /* CONFIG_ST_LSM6DS3_IIO_EXT0_LIS3MDL */
+
+#ifdef ST_LSM6DS3_EXT0_IS_AKM
+	reg_addr = ST_LSM6DS3_SELFTEST_ADDR;
+	temp_reg_status = ST_LSM6DS3_SELFTEST_ENABLE;
+#endif /* ST_LSM6DS3_EXT0_IS_AKM */
+
+	err = st_lsm6ds3_i2c_master_read(sdata->cdata, reg_addr, 1,
+					&reg_status, false, true, false,
+					st_lsm6ds3_exs_list[0].read_data_len);
+	if (err < 0)
+		goto disable_sensor_hub;
+
+#ifdef ST_LSM6DS3_EXT0_IS_AKM
+	/* SLAVE 1 is disabled for a while, dummy write to wai reg */
+	sh_config[0] = (st_lsm6ds3_exs_list[EXT0_INDEX].i2c_addr << 1) | 0x01;
+	sh_config[1] = st_lsm6ds3_exs_list[EXT0_INDEX].wai.addr;
+	sh_config[2] = 1;
+
+	err = st_lsm6ds3_write_embedded_registers(sdata->cdata,
+					ST_LSM6DS3_SLV1_ADDR_ADDR,
+					sh_config, ARRAY_SIZE(sh_config));
+	if (err < 0)
+		goto disable_sensor_hub;
+
+	/* SLAVE 2 is disabled for a while, dummy read of wai reg */
+	sh_config[0] = (st_lsm6ds3_exs_list[EXT0_INDEX].i2c_addr << 1) | 0x01;
+	sh_config[1] = st_lsm6ds3_exs_list[EXT0_INDEX].wai.addr;
+	sh_config[2] = 1;
+
+	err = st_lsm6ds3_write_embedded_registers(sdata->cdata,
+					ST_LSM6DS3_SLV2_ADDR_ADDR,
+					sh_config, ARRAY_SIZE(sh_config));
+	if (err < 0)
+		goto disable_sensor_hub;
+#endif /* ST_LSM6DS3_EXT0_IS_AKM */
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_EXT0_LIS3MDL
+	err = st_lsm6ds3_i2c_master_read(sdata->cdata, reg_addr2, 1,
+					&reg_status2, false, true, false,
+					st_lsm6ds3_exs_list[0].read_data_len);
+	if (err < 0)
+		goto disable_sensor_hub;
+
+	err = st_lsm6ds3_i2c_master_read(sdata->cdata, reg_addr3, 1,
+					&reg_status3, false, true, false,
+					st_lsm6ds3_exs_list[0].read_data_len);
+	if (err < 0)
+		goto disable_sensor_hub;
+#endif /* CONFIG_ST_LSM6DS3_IIO_EXT0_LIS3MDL */
+
+	err = st_lsm6ds3_i2c_master_write(sdata->cdata, reg_addr, 1,
+					&temp_reg_status, false, true);
+	if (err < 0)
+		goto disable_sensor_hub;
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_EXT0_LIS3MDL
+	err = st_lsm6ds3_i2c_master_write(sdata->cdata, reg_addr2, 1,
+					&temp_reg_status2, false, true);
+	if (err < 0)
+		goto restore_status_reg;
+
+	err = st_lsm6ds3_i2c_master_write(sdata->cdata, reg_addr3, 1,
+					&temp_reg_status3, false, true);
+	if (err < 0)
+		goto restore_status_reg2;
+
+	/* get data with selftest disabled */
+	msleep(100);
+
+	for (i = 0; i < 10; i++) {
+		err = sdata->cdata->tf->read(sdata->cdata, sdata->data_out_reg,
+			st_lsm6ds3_exs_list[0].read_data_len, outdata, true);
+		if (err < 0) {
+			i--;
+			continue;
+		}
+
+		x += ((s16)*(u16 *)&outdata[0]) / 10;
+		y += ((s16)*(u16 *)&outdata[2]) / 10;
+		z += ((s16)*(u16 *)&outdata[4]) / 10;
+
+		msleep((1000U / sdata->cdata->trigger_odr) + 2);
+	}
+
+	temp_reg_status = ST_LSM6DS3_SELFTEST_ENABLE;
+
+	err = st_lsm6ds3_i2c_master_write(sdata->cdata, reg_addr, 1,
+					&temp_reg_status, false, true);
+	if (err < 0)
+		goto restore_status_reg3;
+
+	/* get data with selftest disabled */
+	msleep(100);
+
+	for (i = 0; i < 10; i++) {
+		err = sdata->cdata->tf->read(sdata->cdata, sdata->data_out_reg,
+			st_lsm6ds3_exs_list[0].read_data_len, outdata, true);
+		if (err < 0) {
+			i--;
+			continue;
+		}
+
+		x_selftest += ((s16)*(u16 *)&outdata[0]) / 10;
+		y_selftest += ((s16)*(u16 *)&outdata[2]) / 10;
+		z_selftest += ((s16)*(u16 *)&outdata[4]) / 10;
+
+		msleep((1000U / sdata->cdata->trigger_odr) + 2);
+	}
+
+	err = st_lsm6ds3_i2c_master_write(sdata->cdata, reg_addr3, 1,
+						&reg_status3, false, true);
+	if (err < 0)
+		goto restore_status_reg3;
+
+	err = st_lsm6ds3_i2c_master_write(sdata->cdata, reg_addr2, 1,
+						&reg_status2, false, true);
+	if (err < 0)
+		goto restore_status_reg2;
+
+	err = st_lsm6ds3_i2c_master_write(sdata->cdata, reg_addr, 1,
+						&reg_status, false, true);
+	if (err < 0)
+		goto restore_status_reg;
+
+	err = st_lsm6ds3_enable_sensor_hub(sdata->cdata,
+						false, ST_MASK_ID_EXT0);
+	if (err < 0)
+		goto disable_sensor_hub;
+
+	if ((abs(x_selftest - x) < ST_LSM6DS3_SELFTEST_EXT0_MIN) ||
+			(abs(x_selftest - x) > ST_LSM6DS3_SELFTEST_EXT0_MAX)) {
+		sdata->cdata->ext0_selftest_status = -1;
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return size;
+	}
+
+	if ((abs(y_selftest - y) < ST_LSM6DS3_SELFTEST_EXT0_MIN) ||
+			(abs(y_selftest - y) > ST_LSM6DS3_SELFTEST_EXT0_MAX)) {
+		sdata->cdata->ext0_selftest_status = -1;
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return size;
+	}
+
+	if ((abs(z_selftest - z) < ST_LSM6DS3_SELFTEST_EXT0_MIN_Z) ||
+			(abs(z_selftest - z) > ST_LSM6DS3_SELFTEST_EXT0_MAX_Z)) {
+		sdata->cdata->ext0_selftest_status = -1;
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return size;
+	}
+#endif /* CONFIG_ST_LSM6DS3_IIO_EXT0_LIS3MDL */
+
+#ifdef ST_LSM6DS3_EXT0_IS_AKM
+	do {
+		msleep(1000U / sdata->cdata->trigger_odr);
+
+		err = st_lsm6ds3_i2c_master_read(sdata->cdata,
+					ST_LSM6DS3_SELFTEST_STATUS_REG, 1,
+					&temp, false, true, false, 1);
+		if (err < 0)
+			goto restore_status_reg;
+
+		timeout++;
+	} while (((temp & 0x01) == 0) && (timeout < 5));
+
+	if (timeout >= 5) {
+		err = -EINVAL;
+		goto restore_status_reg;
+	}
+
+	err = st_lsm6ds3_i2c_master_read(sdata->cdata,
+			st_lsm6ds3_exs_list[0].data.channels[0].address,
+			st_lsm6ds3_exs_list[0].read_data_len,
+			outdata, false, true, true, 1);
+	if (err < 0)
+		goto restore_status_reg;
+
+#ifdef ST_LSM6DS3_EXT0_IS_AKM
+	/* SLAVE 2 recovering */
+	sh_config[0] = (st_lsm6ds3_exs_list[EXT0_INDEX].i2c_addr << 1) | 0x01;
+	sh_config[1] = st_lsm6ds3_exs_list[0].data.channels[0].address;
+	sh_config[2] = st_lsm6ds3_exs_list[0].read_data_len;
+
+	err = st_lsm6ds3_write_embedded_registers(sdata->cdata,
+					ST_LSM6DS3_SLV1_ADDR_ADDR,
+					sh_config, ARRAY_SIZE(sh_config));
+	if (err < 0)
+		goto restore_status_reg;
+#endif /* ST_LSM6DS3_EXT0_IS_AKM */
+
+	err = st_lsm6ds3_i2c_master_write(sdata->cdata, reg_addr, 1,
+						&reg_status, false, true);
+	if (err < 0)
+		goto restore_status_reg;
+
+	err = st_lsm6ds3_enable_sensor_hub(sdata->cdata,
+						false, ST_MASK_ID_EXT0);
+	if (err < 0)
+		goto disable_sensor_hub;
+
+	x_selftest = ((s16)*(u16 *)&outdata[0]);
+	y_selftest = ((s16)*(u16 *)&outdata[2]);
+	z_selftest = ((s16)*(u16 *)&outdata[4]);
+
+#if defined(CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09912) || \
+			defined(CONFIG_ST_LSM6DS3_IIO_EXT0_AKM09911)
+	x_selftest *= sdata->c_gain[0];
+	y_selftest *= sdata->c_gain[1];
+	z_selftest *= sdata->c_gain[2];
+
+	x_selftest /= 10000;
+	y_selftest /= 10000;
+	z_selftest /= 10000;
+#endif /* CONFIG_ST_LSM6DS3_IIO_EXT0_AKM0991X */
+
+	if ((x_selftest < ST_LSM6DS3_SELFTEST_EXT0_MIN) ||
+			(x_selftest > ST_LSM6DS3_SELFTEST_EXT0_MAX)) {
+		sdata->cdata->ext0_selftest_status = -1;
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return size;
+	}
+
+	if ((y_selftest < ST_LSM6DS3_SELFTEST_EXT0_MIN) ||
+			(y_selftest > ST_LSM6DS3_SELFTEST_EXT0_MAX)) {
+		sdata->cdata->ext0_selftest_status = -1;
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return size;
+	}
+
+	if ((z_selftest < ST_LSM6DS3_SELFTEST_EXT0_MIN_Z) ||
+			(z_selftest > ST_LSM6DS3_SELFTEST_EXT0_MAX_Z)) {
+		sdata->cdata->ext0_selftest_status = -1;
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return size;
+	}
+#endif /* ST_LSM6DS3_EXT0_IS_AKM */
+
+	sdata->cdata->ext0_selftest_status = 1;
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+
+	return size;
+
+#ifdef CONFIG_ST_LSM6DS3_IIO_EXT0_LIS3MDL
+restore_status_reg3:
+	st_lsm6ds3_i2c_master_write(sdata->cdata, reg_addr3, 1,
+						&reg_status3, false, true);
+restore_status_reg2:
+	st_lsm6ds3_i2c_master_write(sdata->cdata, reg_addr2, 1,
+						&reg_status2, false, true);
+#endif /* CONFIG_ST_LSM6DS3_IIO_EXT0_LIS3MDL */
+restore_status_reg:
+	st_lsm6ds3_i2c_master_write(sdata->cdata, reg_addr, 1,
+						&reg_status, false, true);
+disable_sensor_hub:
+	st_lsm6ds3_enable_sensor_hub(sdata->cdata, false, ST_MASK_ID_EXT0);
+	mutex_unlock(&sdata->cdata->odr_lock);
+	return err;
+}
+#endif /* ST_LSM6DS3_EXT0_HAS_SELFTEST	*/
+
+
+static int st_lsm6ds3_i2c_master_set_odr(struct lsm6ds3_sensor_data *sdata,
+						unsigned int odr, bool force)
+{
+	int i, err, err2;
+	u8 value, mask, addr;
+	bool scan_odr = true;
+	unsigned int current_odr = sdata->cdata->v_odr[sdata->sindex];
+	unsigned int current_hw_odr = sdata->cdata->hw_odr[sdata->sindex];
+
+	if (odr == 0) {
+		if (force)
+			scan_odr = false;
+		else
+			return -EINVAL;
+	}
+
+	if (scan_odr) {
+		switch (odr) {
+		case 13:
+		case 26:
+		case 52:
+		case 104:
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		for (i = 0; i < ST_LSM6DS3_ODR_LIST_NUM; i++) {
+			if (st_lsm6ds3_exs_list[0].odr.odr_avl[i].hz >= odr)
+				break;
+		}
+		if (i == ST_LSM6DS3_ODR_LIST_NUM)
+			i--;
+
+		if (!force) {
+			if ((sdata->cdata->sensors_enabled & BIT(sdata->sindex)) == 0) {
+				sdata->cdata->v_odr[sdata->sindex] = odr;
+				return 0;
+			}
+		}
+
+		addr = st_lsm6ds3_exs_list[0].odr.addr;
+		mask = st_lsm6ds3_exs_list[0].odr.mask;
+		value = st_lsm6ds3_exs_list[0].odr.odr_avl[i].value;
+	} else {
+		if (st_lsm6ds3_exs_list[0].power.isodr) {
+			addr = st_lsm6ds3_exs_list[0].power.addr;
+			mask = st_lsm6ds3_exs_list[0].power.mask;
+			value = st_lsm6ds3_exs_list[0].power.off_value;
+		} else
+			goto skip_i2c_write;
+	}
+
+	sdata->cdata->samples_to_discard[ST_MASK_ID_EXT0] =
+				st_lsm6ds3_exs_list[0].samples_to_discard;
+
+	err = st_lsm6ds3_i2c_master_write_data_with_mask(sdata->cdata,
+							addr, mask, value);
+	if (err < 0)
+		return err;
+
+skip_i2c_write:
+	if (odr == 0)
+		sdata->cdata->hw_odr[sdata->sindex] = 0;
+	else
+		sdata->cdata->hw_odr[sdata->sindex] = odr;
+
+	if (!force) {
+		sdata->cdata->v_odr[sdata->sindex] = odr;
+
+		err = st_lsm6ds3_enable_sensor_hub(sdata->cdata,
+							true, ST_MASK_ID_EXT0);
+		if (err < 0) {
+			sdata->cdata->hw_odr[sdata->sindex] = current_hw_odr;
+			sdata->cdata->v_odr[sdata->sindex] = current_odr;
+			do {
+				err2 = st_lsm6ds3_enable_sensor_hub(sdata->cdata,
+							false, ST_MASK_ID_EXT0);
+				msleep(200);
+			} while (err2 < 0);
+
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int st_lsm6ds3_i2c_master_set_enable(
+			struct lsm6ds3_sensor_data *sdata, bool enable, bool buffer)
+{
+	int err;
+	u8 reg_value;
+
+	/* If odr != power this part should enable/disable sensor */
+	if (!st_lsm6ds3_exs_list[0].power.isodr) {
+		if (enable)
+			reg_value = st_lsm6ds3_exs_list[0].power.on_value;
+		else
+			reg_value = st_lsm6ds3_exs_list[0].power.off_value;
+
+		err = st_lsm6ds3_i2c_master_write_data_with_mask(sdata->cdata,
+					st_lsm6ds3_exs_list[0].power.addr,
+					st_lsm6ds3_exs_list[0].power.mask,
+					reg_value);
+		if (err < 0)
+			return err;
+	}
+
+	err =  st_lsm6ds3_enable_sensor_hub(sdata->cdata,
+						enable, ST_MASK_ID_EXT0);
+	if (err < 0)
+		return err;
+
+	err = st_lsm6ds3_i2c_master_set_odr(sdata,
+			enable ? sdata->cdata->v_odr[sdata->sindex] : 0, true);
+	if (err < 0)
+		goto disable_sensorhub;
+
+	if (buffer) {
+		err = st_lsm6ds3_set_drdy_irq(sdata, enable);
+		if (err < 0)
+			goto restore_odr;
+
+		if (enable)
+			sdata->cdata->sensors_enabled |= BIT(sdata->sindex);
+		else
+			sdata->cdata->sensors_enabled &= ~BIT(sdata->sindex);
+	}
+
+	return 0;
+
+restore_odr:
+	st_lsm6ds3_i2c_master_set_odr(sdata,
+			enable ? 0 : sdata->cdata->v_odr[sdata->sindex], true);
+disable_sensorhub:
+	st_lsm6ds3_enable_sensor_hub(sdata->cdata, !enable, ST_MASK_ID_EXT0);
+
+	return err;
+}
+
+static int st_lsm6ds3_i2c_master_read_raw(struct iio_dev *indio_dev,
+		struct iio_chan_spec const *ch, int *val, int *val2, long mask)
+{
+	int err;
+	u8 outdata[(ch->scan_type.storagebits >> 3)];
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		mutex_lock(&indio_dev->mlock);
+
+		if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+			mutex_unlock(&indio_dev->mlock);
+			return -EBUSY;
+		}
+
+		mutex_lock(&sdata->cdata->odr_lock);
+
+		err = st_lsm6ds3_i2c_master_set_enable(sdata, true, false);
+		if (err < 0) {
+			mutex_unlock(&sdata->cdata->odr_lock);
+			mutex_unlock(&indio_dev->mlock);
+			return err;
+		}
+
+		st_lsm6ds3_master_wait_completed(sdata->cdata);
+
+		msleep((1000U / sdata->cdata->trigger_odr) + 2);
+
+		err = sdata->cdata->tf->read(sdata->cdata, sdata->data_out_reg,
+				ch->scan_type.storagebits >> 3, outdata, true);
+		if (err < 0) {
+			st_lsm6ds3_i2c_master_set_enable(sdata, false, false);
+			mutex_unlock(&sdata->cdata->odr_lock);
+			mutex_unlock(&indio_dev->mlock);
+			return err;
+		}
+
+		err = st_lsm6ds3_i2c_master_set_enable(sdata, false, false);
+		if (err < 0) {
+			mutex_unlock(&sdata->cdata->odr_lock);
+			mutex_unlock(&indio_dev->mlock);
+			return err;
+		}
+
+		if ((ch->scan_type.storagebits >> 3) > 2)
+			*val = (s32)get_unaligned_le32(outdata);
+		else
+			*val = (s16)get_unaligned_le16(outdata);
+
+		*val = *val >> ch->scan_type.shift;
+
+		mutex_unlock(&sdata->cdata->odr_lock);
+		mutex_unlock(&indio_dev->mlock);
+
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		*val = 0;
+		*val2 = sdata->c_gain[ch->scan_index];
+
+		if (ch->type == IIO_TEMP) {
+			*val = 1;
+			*val2 = 0;
+			return IIO_VAL_INT;
+		}
+
+		return IIO_VAL_INT_PLUS_MICRO;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int st_lsm6ds3_i2c_master_buffer_preenable(struct iio_dev *indio_dev)
+{
+#ifdef CONFIG_ST_LSM6DS3_XL_DATA_INJECTION
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	if (sdata->cdata->injection_mode)
+		return -EBUSY;
+#endif /* CONFIG_ST_LSM6DS3_XL_DATA_INJECTION */
+
+	return 0;
+}
+
+static int st_lsm6ds3_i2c_master_buffer_postenable(struct iio_dev *indio_dev)
+{
+	int err;
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	sdata->cdata->fifo_output[sdata->sindex].initialized = false;
+
+	if ((sdata->cdata->hwfifo_enabled[ST_MASK_ID_EXT0]) &&
+		(indio_dev->buffer->length < 2 * ST_LSM6DS3_MAX_FIFO_LENGHT))
+		return -EINVAL;
+
+	err = iio_triggered_buffer_postenable(indio_dev);
+	if (err < 0)
+		return err;
+
+	sdata->buffer_data = kmalloc(indio_dev->scan_bytes, GFP_KERNEL);
+	if (!sdata->buffer_data)
+		return -ENOMEM;
+
+	mutex_lock(&sdata->cdata->odr_lock);
+
+	err = st_lsm6ds3_i2c_master_set_enable(sdata, true, true);
+	if (err < 0) {
+		mutex_unlock(&sdata->cdata->odr_lock);
+		return err;
+	}
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+
+	return 0;
+}
+
+static int st_lsm6ds3_i2c_master_buffer_predisable(struct iio_dev *indio_dev)
+{
+	return iio_triggered_buffer_predisable(indio_dev);
+}
+
+static int st_lsm6ds3_i2c_master_buffer_postdisable(struct iio_dev *indio_dev)
+{
+	int err;
+	struct lsm6ds3_sensor_data *sdata = iio_priv(indio_dev);
+
+	mutex_lock(&sdata->cdata->odr_lock);
+
+	err = st_lsm6ds3_i2c_master_set_enable(sdata, false, true);
+
+	mutex_unlock(&sdata->cdata->odr_lock);
+
+	kfree(sdata->buffer_data);
+
+	return err < 0 ? err : 0;
+}
+
+static const struct iio_trigger_ops st_lsm6ds3_i2c_master_trigger_ops = {
+	.owner = THIS_MODULE,
+	.set_trigger_state = &st_lsm6ds3_trig_set_state,
+};
+
+int st_lsm6ds3_i2c_master_allocate_trigger(struct lsm6ds3_data *cdata)
+{
+	int err;
+
+	cdata->trig[ST_MASK_ID_EXT0] = iio_trigger_alloc("%s-trigger",
+				cdata->indio_dev[ST_MASK_ID_EXT0]->name);
+	if (!cdata->trig[ST_MASK_ID_EXT0]) {
+		dev_err(cdata->dev, "failed to allocate iio trigger.\n");
+		return -ENOMEM;
+	}
+
+	iio_trigger_set_drvdata(cdata->trig[ST_MASK_ID_EXT0],
+					cdata->indio_dev[ST_MASK_ID_EXT0]);
+	cdata->trig[ST_MASK_ID_EXT0]->ops = &st_lsm6ds3_i2c_master_trigger_ops;
+	cdata->trig[ST_MASK_ID_EXT0]->dev.parent = cdata->dev;
+
+	err = iio_trigger_register(cdata->trig[ST_MASK_ID_EXT0]);
+	if (err < 0) {
+		dev_err(cdata->dev, "failed to register iio trigger.\n");
+		goto deallocate_trigger;
+	}
+
+	cdata->indio_dev[ST_MASK_ID_EXT0]->trig = cdata->trig[ST_MASK_ID_EXT0];
+
+	return 0;
+
+deallocate_trigger:
+	iio_trigger_free(cdata->trig[ST_MASK_ID_EXT0]);
+	return err;
+}
+
+static void st_lsm6ds3_i2c_master_deallocate_trigger(struct lsm6ds3_data *cdata)
+{
+	iio_trigger_unregister(cdata->trig[ST_MASK_ID_EXT0]);
+}
+
+static const struct iio_buffer_setup_ops st_lsm6ds3_i2c_master_buffer_setup_ops = {
+	.preenable = &st_lsm6ds3_i2c_master_buffer_preenable,
+	.postenable = &st_lsm6ds3_i2c_master_buffer_postenable,
+	.predisable = &st_lsm6ds3_i2c_master_buffer_predisable,
+	.postdisable = &st_lsm6ds3_i2c_master_buffer_postdisable,
+};
+
+static inline irqreturn_t st_lsm6ds3_i2c_master_handler_empty(int irq, void *p)
+{
+	return IRQ_HANDLED;
+}
+
+static int st_lsm6ds3_i2c_master_allocate_buffer(struct lsm6ds3_data *cdata)
+{
+	return iio_triggered_buffer_setup(cdata->indio_dev[ST_MASK_ID_EXT0],
+				&st_lsm6ds3_i2c_master_handler_empty, NULL,
+				&st_lsm6ds3_i2c_master_buffer_setup_ops);
+}
+
+static void st_lsm6ds3_i2c_master_deallocate_buffer(struct lsm6ds3_data *cdata)
+{
+	iio_triggered_buffer_cleanup(cdata->indio_dev[ST_MASK_ID_EXT0]);
+}
+
+static int st_lsm6ds3_i2c_master_send_sensor_hub_parameters(
+					struct lsm6ds3_sensor_data *sdata)
+{
+	int err;
+	u8 sh_config[3];
+
+	/* SLAVE 0 is used by write */
+	sh_config[0] = (st_lsm6ds3_exs_list[EXT0_INDEX].i2c_addr << 1);
+	sh_config[1] = st_lsm6ds3_exs_list[EXT0_INDEX].wai.addr;
+	sh_config[2] = 0x01 | 0x20;
+
+	err = st_lsm6ds3_write_embedded_registers(sdata->cdata,
+					ST_LSM6DS3_SLV0_ADDR_ADDR, sh_config,
+					ARRAY_SIZE(sh_config));
+	if (err < 0)
+		return err;
+
+	/* SLAVE 1 is used to read output data */
+	sh_config[0] = (st_lsm6ds3_exs_list[EXT0_INDEX].i2c_addr << 1) | ST_LSM6DS3_EN_BIT;
+	sh_config[1] = st_lsm6ds3_exs_list[0].data.channels[0].address;
+	sh_config[2] = st_lsm6ds3_exs_list[0].read_data_len;
+
+	err = st_lsm6ds3_write_embedded_registers(sdata->cdata,
+					ST_LSM6DS3_SLV1_ADDR_ADDR,
+					sh_config, ARRAY_SIZE(sh_config));
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int st_lsm6ds3_i2c_master_init_sensor(struct lsm6ds3_sensor_data *sdata)
+{
+	int err, ext_num = 0;
+
+	err = st_lsm6ds3_i2c_master_send_sensor_hub_parameters(sdata);
+	if (err < 0)
+		return err;
+
+	sdata->c_gain[0] = st_lsm6ds3_exs_list[ext_num].gain;
+	sdata->c_gain[1] = st_lsm6ds3_exs_list[ext_num].gain;
+	sdata->c_gain[2] = st_lsm6ds3_exs_list[ext_num].gain;
+
+	if ((st_lsm6ds3_exs_list[ext_num].power.addr ==
+				st_lsm6ds3_exs_list[ext_num].odr.addr) &&
+			(st_lsm6ds3_exs_list[ext_num].power.mask ==
+					st_lsm6ds3_exs_list[ext_num].odr.mask))
+		st_lsm6ds3_exs_list[ext_num].power.isodr = true;
+	else
+		st_lsm6ds3_exs_list[ext_num].power.isodr = false;
+
+	err = st_lsm6ds3_i2c_master_write_data_with_mask(sdata->cdata,
+					st_lsm6ds3_exs_list[ext_num].reset.addr,
+					st_lsm6ds3_exs_list[ext_num].reset.mask,
+					ST_LSM6DS3_EN_BIT);
+	if (err < 0)
+		return err;
+
+	usleep_range(200, 1000);
+
+	if (st_lsm6ds3_exs_list[ext_num].fullscale.addr > 0) {
+		err = st_lsm6ds3_i2c_master_write_data_with_mask(sdata->cdata,
+			st_lsm6ds3_exs_list[ext_num].fullscale.addr,
+			st_lsm6ds3_exs_list[ext_num].fullscale.mask,
+			st_lsm6ds3_exs_list[ext_num].fullscale.def_value);
+		if (err < 0)
+			return err;
+	}
+
+	if (st_lsm6ds3_exs_list[0].cf.boot_initialization != NULL) {
+		err = st_lsm6ds3_exs_list[0].cf.boot_initialization(sdata);
+		if (err < 0)
+			return err;
+	}
+
+	err = st_lsm6ds3_i2c_master_set_enable(sdata, false, false);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int st_lsm6ds3_i2c_master_allocate_device(struct lsm6ds3_data *cdata)
+{
+	int err;
+	struct lsm6ds3_sensor_data *sdata_ext;
+
+
+	sdata_ext = iio_priv(cdata->indio_dev[ST_MASK_ID_EXT0]);
+
+	sdata_ext->num_data_channels =
+				st_lsm6ds3_exs_list[0].num_data_channels;
+
+	cdata->indio_dev[ST_MASK_ID_EXT0]->name = kasprintf(GFP_KERNEL,
+				"%s_%s", cdata->name,
+				st_lsm6ds3_exs_list[0].data.suffix_name);
+
+	cdata->indio_dev[ST_MASK_ID_EXT0]->info =
+				st_lsm6ds3_exs_list[0].data.info;
+	cdata->indio_dev[ST_MASK_ID_EXT0]->channels =
+				st_lsm6ds3_exs_list[0].data.channels;
+	cdata->indio_dev[ST_MASK_ID_EXT0]->num_channels =
+				st_lsm6ds3_exs_list[0].data.num_channels;
+
+	cdata->indio_dev[ST_MASK_ID_EXT0]->modes = INDIO_DIRECT_MODE;
+
+	sdata_ext->data_out_reg = ST_LSM6DS3_SLV0_OUT_ADDR;
+
+	err = st_lsm6ds3_i2c_master_init_sensor(sdata_ext);
+	if (err < 0)
+		goto iio_device_free;
+
+	err = st_lsm6ds3_i2c_master_allocate_buffer(cdata);
+	if (err < 0)
+		goto iio_device_free;
+
+	err = st_lsm6ds3_i2c_master_allocate_trigger(cdata);
+	if (err < 0)
+		goto iio_deallocate_buffer;
+
+	err = iio_device_register(cdata->indio_dev[ST_MASK_ID_EXT0]);
+	if (err < 0)
+		goto iio_deallocate_trigger;
+
+	return 0;
+
+iio_deallocate_trigger:
+	st_lsm6ds3_i2c_master_deallocate_trigger(cdata);
+iio_deallocate_buffer:
+	st_lsm6ds3_i2c_master_deallocate_buffer(cdata);
+iio_device_free:
+	iio_device_free(cdata->indio_dev[ST_MASK_ID_EXT0]);
+
+	return err;
+}
+
+static void st_lsm6ds3_i2c_master_deallocate_device(struct lsm6ds3_data *cdata)
+{
+	iio_device_unregister(cdata->indio_dev[ST_MASK_ID_EXT0]);
+	st_lsm6ds3_i2c_master_deallocate_trigger(cdata);
+	st_lsm6ds3_i2c_master_deallocate_buffer(cdata);
+	iio_device_free(cdata->indio_dev[ST_MASK_ID_EXT0]);
+}
+
+int st_lsm6ds3_i2c_master_probe(struct lsm6ds3_data *cdata)
+{
+	int err, i;
+	u8 sh_config[3];
+	u8 wai, i2c_address;
+	struct lsm6ds3_sensor_data *sdata_ext;
+
+	mutex_init(&cdata->i2c_transfer_lock);
+	cdata->ext0_available = false;
+	cdata->ext0_selftest_status = false;
+
+#ifdef CONFIG_ST_LSM6DS3_ENABLE_INTERNAL_PULLUP
+	err = st_lsm6ds3_write_data_with_mask(cdata,
+					ST_LSM6DS3_INTER_PULLUP_ADDR,
+					ST_LSM6DS3_INTER_PULLUP_MASK,
+					ST_LSM6DS3_EN_BIT, true);
+	if (err < 0)
+		return err;
+#endif /* CONFIG_ST_LSM6DS3_ENABLE_INTERNAL_PULLUP */
+
+	err = st_lsm6ds3_write_data_with_mask(cdata,
+					ST_LSM6DS3_FUNC_MAX_RATE_ADDR,
+					ST_LSM6DS3_FUNC_MAX_RATE_MASK, 1, true);
+	if (err < 0)
+		return err;
+
+	cdata->indio_dev[ST_MASK_ID_EXT0] = iio_device_alloc(sizeof(*sdata_ext));
+	if (!cdata->indio_dev[ST_MASK_ID_EXT0])
+		return -ENOMEM;
+
+	sdata_ext = iio_priv(cdata->indio_dev[ST_MASK_ID_EXT0]);
+	sdata_ext->cdata = cdata;
+	sdata_ext->sindex = ST_MASK_ID_EXT0;
+	cdata->samples_to_discard_2[ST_MASK_ID_EXT0] = 0;
+	sdata_ext->cdata->fifo_output[ST_MASK_ID_EXT0].sip = 0;
+	sdata_ext->cdata->fifo_output[ST_MASK_ID_EXT0].timestamp_p = 0;
+
+	for (i = 0; i < 2; i++) {
+		if (i == 0)
+			i2c_address = ST_LSM6DS3_EXT0_ADDR;
+		else
+			i2c_address = ST_LSM6DS3_EXT0_ADDR2;
+
+		/* to check if sensor is available use SLAVE0 first time */
+		sh_config[0] = (i2c_address << 1) | 0x01;
+		sh_config[1] = st_lsm6ds3_exs_list[EXT0_INDEX].wai.addr;
+		sh_config[2] = 0x01;
+
+		err = st_lsm6ds3_write_embedded_registers(cdata,
+					ST_LSM6DS3_SLV0_ADDR_ADDR, sh_config,
+					ARRAY_SIZE(sh_config));
+		if (err < 0)
+			return err;
+
+		err = st_lsm6ds3_enable_sensor_hub(cdata, true,
+					ST_MASK_ID_SENSOR_HUB_ASYNC_OP);
+		if (err < 0)
+			return err;
+
+		msleep(100);
+
+		st_lsm6ds3_master_wait_completed(cdata);
+
+		err = cdata->tf->read(cdata, ST_LSM6DS3_SLV0_OUT_ADDR,
+								1, &wai, true);
+		if (err < 0) {
+			err = st_lsm6ds3_enable_sensor_hub(cdata, false,
+					ST_MASK_ID_SENSOR_HUB_ASYNC_OP);
+			if (err < 0)
+				return err;
+
+			continue;
+		}
+
+		err = st_lsm6ds3_enable_sensor_hub(cdata, false,
+					ST_MASK_ID_SENSOR_HUB_ASYNC_OP);
+		if (err < 0)
+			return err;
+
+		st_lsm6ds3_exs_list[EXT0_INDEX].i2c_addr = i2c_address;
+		break;
+	}
+	if (i == 2)
+		goto ext0_sensor_not_available;
+
+	/* after wai check SLAVE0 is used for write, SLAVE1 for async read
+	   and SLAVE2 to read sensor output data */
+
+	if (wai != st_lsm6ds3_exs_list[EXT0_INDEX].wai.def_value) {
+		dev_err(cdata->dev, "wai value of external sensor 0 mismatch\n");
+		return err;
+	}
+
+	err = st_lsm6ds3_i2c_master_allocate_device(cdata);
+	if (err < 0)
+		return err;
+
+	cdata->ext0_available = true;
+
+	return 0;
+
+ext0_sensor_not_available:
+	dev_err(cdata->dev, "external sensor 0 not available\n");
+
+	return err;
+}
+EXPORT_SYMBOL(st_lsm6ds3_i2c_master_probe);
+
+int st_lsm6ds3_i2c_master_exit(struct lsm6ds3_data *cdata)
+{
+	if (cdata->ext0_available)
+		st_lsm6ds3_i2c_master_deallocate_device(cdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(st_lsm6ds3_i2c_master_exit);
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics lsm6ds3 i2c master driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_spi.c b/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_spi.c
new file mode 100755
index 0000000..98a11d8
--- /dev/null
+++ b/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_spi.c
@@ -0,0 +1,201 @@
+/*
+ * STMicroelectronics lsm6ds3 spi driver
+ *
+ * Copyright 2014-2016 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/of.h>
+#include <linux/iio/iio.h>
+
+#include "st_lsm6ds3.h"
+
+#define ST_SENSORS_SPI_READ			0x80
+
+static int st_lsm6ds3_spi_read(struct lsm6ds3_data *cdata,
+				u8 reg_addr, int len, u8 *data, bool b_lock)
+{
+	int err;
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (b_lock)
+		mutex_lock(&cdata->bank_registers_lock);
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr | ST_SENSORS_SPI_READ;
+
+	err = spi_sync_transfer(to_spi_device(cdata->dev),
+						xfers, ARRAY_SIZE(xfers));
+	if (err)
+		goto acc_spi_read_error;
+
+	memcpy(data, cdata->tb.rx_buf, len*sizeof(u8));
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return len;
+
+acc_spi_read_error:
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return err;
+}
+
+static int st_lsm6ds3_spi_write(struct lsm6ds3_data *cdata,
+				u8 reg_addr, int len, u8 *data, bool b_lock)
+{
+	int err;
+
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= ST_LSM6DS3_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (b_lock)
+		mutex_lock(&cdata->bank_registers_lock);
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr;
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	err = spi_sync_transfer(to_spi_device(cdata->dev), &xfers, 1);
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return err;
+}
+
+static const struct st_lsm6ds3_transfer_function st_lsm6ds3_tf_spi = {
+	.write = st_lsm6ds3_spi_write,
+	.read = st_lsm6ds3_spi_read,
+};
+
+static int st_lsm6ds3_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lsm6ds3_data *cdata;
+
+	cdata = kmalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &spi->dev;
+	cdata->name = spi->modalias;
+	spi_set_drvdata(spi, cdata);
+
+	cdata->spi_connection = true;
+	cdata->tf = &st_lsm6ds3_tf_spi;
+
+	err = st_lsm6ds3_common_probe(cdata, spi->irq);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+	return err;
+}
+
+static int st_lsm6ds3_spi_remove(struct spi_device *spi)
+{
+	struct lsm6ds3_data *cdata = spi_get_drvdata(spi);
+
+	st_lsm6ds3_common_remove(cdata, spi->irq);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int st_lsm6ds3_suspend(struct device *dev)
+{
+	struct lsm6ds3_data *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return st_lsm6ds3_common_suspend(cdata);
+}
+
+static int st_lsm6ds3_resume(struct device *dev)
+{
+	struct lsm6ds3_data *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return st_lsm6ds3_common_resume(cdata);
+}
+
+static const struct dev_pm_ops st_lsm6ds3_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(st_lsm6ds3_suspend, st_lsm6ds3_resume)
+};
+
+#define ST_LSM6DS3_PM_OPS		(&st_lsm6ds3_pm_ops)
+#else /* CONFIG_PM */
+#define ST_LSM6DS3_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id st_lsm6ds3_id_table[] = {
+	{ LSM6DS3_DEV_NAME },
+	{ LSM6DS33_DEV_NAME },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, st_lsm6ds3_id_table);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm6ds3_of_match[] = {
+	{
+		.compatible = "st,lsm6ds3",
+		.data = LSM6DS3_DEV_NAME,
+	},
+	{
+		.compatible = "st,lsm6ds33",
+		.data = LSM6DS33_DEV_NAME,
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, lsm6ds3_of_match);
+#else /* CONFIG_OF */
+#define lsm6ds3_of_match		NULL
+#endif /* CONFIG_OF */
+
+static struct spi_driver st_lsm6ds3_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "st-lsm6ds3-spi",
+		.pm = ST_LSM6DS3_PM_OPS,
+		.of_match_table = of_match_ptr(lsm6ds3_of_match),
+	},
+	.probe = st_lsm6ds3_spi_probe,
+	.remove = st_lsm6ds3_spi_remove,
+	.id_table = st_lsm6ds3_id_table,
+};
+module_spi_driver(st_lsm6ds3_driver);
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics lsm6ds3 spi driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_trigger.c b/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_trigger.c
new file mode 100755
index 0000000..d804070
--- /dev/null
+++ b/drivers/iio/imu/st_lsm6ds3/st_lsm6ds3_trigger.c
@@ -0,0 +1,206 @@
+/*
+ * STMicroelectronics lsm6ds3 trigger driver
+ *
+ * Copyright 2014-2016 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/trigger.h>
+#include <linux/interrupt.h>
+#include <linux/iio/events.h>
+
+#include "st_lsm6ds3.h"
+
+#define ST_LSM6DS3_DIS_BIT				0x00
+#define ST_LSM6DS3_SRC_FUNC_ADDR			0x53
+#define ST_LSM6DS3_FIFO_DATA_AVL_ADDR			0x3b
+#define ST_LSM6DS3_ACCEL_DATA_AVL_ADDR			0x1e
+
+#define ST_LSM6DS3_ACCEL_DATA_AVL			0x01
+#define ST_LSM6DS3_GYRO_DATA_AVL			0x02
+#define ST_LSM6DS3_SRC_STEP_DETECTOR_DATA_AVL		0x10
+#define ST_LSM6DS3_SRC_TILT_DATA_AVL			0x20
+#define ST_LSM6DS3_SRC_STEP_COUNTER_DATA_AVL		0x80
+#define ST_LSM6DS3_SRC_STEP_COUNTER_DATA_OVR		0x08
+#define ST_LSM6DS3_FIFO_DATA_AVL			0x80
+#define ST_LSM6DS3_FIFO_DATA_OVR			0x40
+
+
+static irqreturn_t lsm6ds3_irq_management(int irq, void *private)
+{
+	int err;
+	bool push;
+	struct timespec ts;
+	bool force_read_accel = false;
+	struct lsm6ds3_data *cdata = private;
+	u8 src_accel_gyro = 0, src_dig_func = 0;
+
+	get_monotonic_boottime(&ts);
+	cdata->timestamp = timespec_to_ns(&ts);
+
+	if ((cdata->sensors_enabled & ~cdata->sensors_use_fifo) &
+			(BIT(ST_MASK_ID_ACCEL) | BIT(ST_MASK_ID_GYRO) |
+						BIT(ST_MASK_ID_EXT0))) {
+		err = cdata->tf->read(cdata, ST_LSM6DS3_ACCEL_DATA_AVL_ADDR,
+						1, &src_accel_gyro, true);
+		if (err < 0)
+			goto read_fifo_status;
+
+		if (src_accel_gyro & ST_LSM6DS3_ACCEL_DATA_AVL) {
+#ifdef CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT
+			if ((cdata->sensors_enabled & ~cdata->sensors_use_fifo)
+						& BIT(ST_MASK_ID_EXT0)) {
+				cdata->nofifo_decimation[ST_MASK_ID_EXT0].num_samples++;
+				force_read_accel = true;
+
+				if ((cdata->nofifo_decimation[ST_MASK_ID_EXT0].num_samples %
+						cdata->nofifo_decimation[ST_MASK_ID_EXT0].decimator) == 0) {
+					push = true;
+					cdata->nofifo_decimation[ST_MASK_ID_EXT0].num_samples = 0;
+				} else
+					push = false;
+
+					lsm6ds3_read_output_data(cdata, ST_MASK_ID_EXT0, push);
+			}
+#endif /* CONFIG_ST_LSM6DS3_IIO_MASTER_SUPPORT */
+
+			if ((cdata->sensors_enabled & ~cdata->sensors_use_fifo) &
+							BIT(ST_MASK_ID_ACCEL)) {
+				cdata->nofifo_decimation[ST_MASK_ID_ACCEL].num_samples++;
+
+				if ((cdata->nofifo_decimation[ST_MASK_ID_ACCEL].num_samples %
+						cdata->nofifo_decimation[ST_MASK_ID_ACCEL].decimator) == 0) {
+					push = true;
+					cdata->nofifo_decimation[ST_MASK_ID_ACCEL].num_samples = 0;
+				} else
+					push = false;
+
+				lsm6ds3_read_output_data(cdata, ST_MASK_ID_ACCEL, push);
+			} else {
+				if (force_read_accel)
+					lsm6ds3_read_output_data(cdata, ST_MASK_ID_ACCEL, false);
+			}
+
+		}
+
+		if (src_accel_gyro & ST_LSM6DS3_GYRO_DATA_AVL) {
+			if ((cdata->sensors_enabled & ~cdata->sensors_use_fifo) & BIT(ST_MASK_ID_GYRO))
+				lsm6ds3_read_output_data(cdata, ST_MASK_ID_GYRO, true);
+		}
+	}
+
+read_fifo_status:
+	if (cdata->sensors_use_fifo)
+		st_lsm6ds3_read_fifo(cdata, false);
+
+	err = cdata->tf->read(cdata, ST_LSM6DS3_SRC_FUNC_ADDR,
+						1, &src_dig_func, true);
+	if (err < 0)
+		goto exit_irq;
+
+	if (src_dig_func & ST_LSM6DS3_SRC_STEP_DETECTOR_DATA_AVL) {
+		if (cdata->sensors_enabled & BIT(ST_MASK_ID_STEP_DETECTOR)) {
+			st_lsm6ds3_push_data_with_timestamp(cdata,
+				ST_MASK_ID_STEP_DETECTOR, NULL, cdata->timestamp);
+		}
+
+		if ((cdata->sign_motion_event_ready) &&
+				(cdata->sensors_enabled &
+					BIT(ST_MASK_ID_SIGN_MOTION))) {
+			iio_push_event(cdata->indio_dev[
+				ST_MASK_ID_SIGN_MOTION],
+				IIO_UNMOD_EVENT_CODE(IIO_SIGN_MOTION,
+				0, IIO_EV_TYPE_THRESH, IIO_EV_DIR_EITHER),
+				cdata->timestamp);
+
+			cdata->sign_motion_event_ready = false;
+		}
+	}
+
+	if (src_dig_func & ST_LSM6DS3_SRC_STEP_COUNTER_DATA_OVR)
+		cdata->num_steps += (1 << 16);
+
+	if (src_dig_func & ST_LSM6DS3_SRC_STEP_COUNTER_DATA_AVL)
+		iio_trigger_poll_chained(cdata->trig[ST_MASK_ID_STEP_COUNTER]);
+
+	if ((src_dig_func & ST_LSM6DS3_SRC_TILT_DATA_AVL) &&
+				(cdata->sensors_enabled & BIT(ST_MASK_ID_TILT))) {
+		st_lsm6ds3_push_data_with_timestamp(cdata,
+				ST_MASK_ID_TILT, NULL, cdata->timestamp);
+	}
+
+exit_irq:
+	return IRQ_HANDLED;
+}
+
+int st_lsm6ds3_allocate_triggers(struct lsm6ds3_data *cdata,
+				const struct iio_trigger_ops *trigger_ops)
+{
+	int err, i, n;
+
+	for (i = 0; i < ST_INDIO_DEV_NUM; i++) {
+		cdata->trig[i] = iio_trigger_alloc("%s-trigger",
+						cdata->indio_dev[i]->name);
+		if (!cdata->trig[i]) {
+			dev_err(cdata->dev,
+					"failed to allocate iio trigger.\n");
+			err = -ENOMEM;
+			goto deallocate_trigger;
+		}
+		iio_trigger_set_drvdata(cdata->trig[i], cdata->indio_dev[i]);
+		cdata->trig[i]->ops = trigger_ops;
+		cdata->trig[i]->dev.parent = cdata->dev;
+	}
+
+	err = request_threaded_irq(cdata->irq, NULL, lsm6ds3_irq_management,
+					IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
+					cdata->name, cdata);
+	if (err)
+		goto deallocate_trigger;
+
+	for (n = 0; n < ST_INDIO_DEV_NUM; n++) {
+		err = iio_trigger_register(cdata->trig[n]);
+		if (err < 0) {
+			dev_err(cdata->dev,
+					"failed to register iio trigger.\n");
+			goto free_irq;
+		}
+		cdata->indio_dev[n]->trig = cdata->trig[n];
+	}
+
+	return 0;
+
+free_irq:
+	free_irq(cdata->irq, cdata);
+	for (n--; n >= 0; n--)
+		iio_trigger_unregister(cdata->trig[n]);
+deallocate_trigger:
+	for (i--; i >= 0; i--)
+		iio_trigger_free(cdata->trig[i]);
+
+	return err;
+}
+EXPORT_SYMBOL(st_lsm6ds3_allocate_triggers);
+
+void st_lsm6ds3_deallocate_triggers(struct lsm6ds3_data *cdata)
+{
+	int i;
+
+	free_irq(cdata->irq, cdata);
+
+	for (i = 0; i < ST_INDIO_DEV_NUM; i++)
+		iio_trigger_unregister(cdata->trig[i]);
+}
+EXPORT_SYMBOL(st_lsm6ds3_deallocate_triggers);
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics lsm6ds3 trigger driver");
+MODULE_LICENSE("GPL v2");
-- 
2.7.4

